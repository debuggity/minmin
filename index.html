<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MinMin [grdn_OS]</title>
    <style>
        :root {
            --primary-color: #00FF00;
            --bg-color: #000000;
            --border-color: #00FF00;
            --cell-bg: #003300;
            --cell-border: #004400;
            --cell-revealed-bg: #001500;
            --cell-revealed-border: #002500;
            --font-family: 'Consolas', 'Courier New', monospace;
        }

        body {
            background-color: var(--bg-color);
            color: var(--primary-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin: 0;
            padding: 20px;
            overflow-y: auto;
            min-height: 100vh;
            box-sizing: border-box;
        }

        #arcade-shell {
            border: 1px solid var(--border-color);
            padding: 15px;
            width: 95%;
            max-width: 1000px;
            box-shadow: 0 0 10px var(--border-color), 0 0 20px var(--border-color) inset;
        }

        h1, h2, h3 {
            color: var(--primary-color);
            text-shadow: 0 0 5px var(--primary-color);
            margin-top: 0;
        }

        #header { text-align: center; margin-bottom: 15px; }

        #global-info-panel {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px dashed var(--border-color);
        }
        #global-info-panel span { margin: 5px 10px; }

        #game-specific-area {
            min-height: 400px; /* Ensure space for games */
            border: 1px solid #005000;
            background-color: #001000;
            padding: 10px;
            margin-bottom: 15px;
            display: flex; /* For centering game content */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: none;
        }

        /* Common Grid Cell Styling (can be overridden by specific games) */
        .grid-display {
            display: grid;
            gap: 1px;
            border: 1px solid #005000;
            background-color: #001000;
            user-select: none;
            touch-action: none; /* Prevent double tap zoom on mobile */
            margin: auto; /* Center grid if smaller than container */
        }

        .grid-cell {
            width: 20px;
            height: 20px;
            background-color: var(--cell-bg);
            border: 1px solid var(--cell-border);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
            color: var(--primary-color);
            position: relative; /* For decision point marker */
        }

        #log-area-container {
            margin-top: 15px;
            border: 1px dashed var(--border-color);
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            background-color: #001000;
        }
        #log-area-container pre { margin: 0; white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em; }

        button {
            background-color: #004400;
            color: var(--primary-color);
            border: 1px solid var(--border-color);
            padding: 8px 15px;
            cursor: pointer;
            font-family: inherit;
            text-shadow: 0 0 3px var(--primary-color);
            margin-top: 10px;
        }
        button:hover {
            background-color: #006600;
            box-shadow: 0 0 8px var(--primary-color);
        }
        button:disabled {
            background-color: #002200;
            color: #005500;
            border-color: #005500;
            cursor: not-allowed;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 20, 0, 0.95);
            display: flex; /* Initially hidden, shown by JS */
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 15px;
            box-sizing: border-box;
        }
        #overlay-content {
            background-color: #000000;
            border: 2px solid #00FF00;
            box-shadow:
                0 0 15px #00FF00,
                0 0 30px #00FF00 inset,
                0 0 3px  #00A0FF inset;   /* subtle blue inner-glow */
            padding: 24px 34px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            font-family: var(--font-family);
            color: var(--primary-color);
            text-shadow: 0 0 4px var(--primary-color);
        }

        #overlay-content h2 { font-size: 1.8em; margin-bottom: 15px; }
        #overlay-content p { margin-bottom: 15px; font-size: 1.1em; }
        #overlay-content pre { text-align: left; white-space: pre-wrap; max-height: 300px; overflow-y: auto;}
        
        #overlay.console-mode #overlay-content{
            background:#000;                           /* jet-black shell   */
            border:2px solid #00ff00;                  /* neon border       */
            box-shadow:0 0 15px #00ff00,
                    0 0 25px #00ff00 inset;         /* CRT glow          */
        }
        #overlay-console-text{                         /* scrolling text area */
            font-family:'Consolas','Courier New',monospace;
            color:#00ff00;
            text-shadow:0 0 3px #00ff00;
            white-space:pre-wrap;                      /* keep \n spacing   */
            line-height:1.35;
        }

        .blinking-cursor {
            animation: blink 1s step-end infinite;
        }
        @keyframes blink {
            50% { opacity: 0; }
        }

        /* Minesweeper Specific Styles */
        .sweeper-cell.revealed { background-color: var(--cell-revealed-bg); border-color: var(--cell-revealed-border); cursor: default; }
        .sweeper-cell.mine::before { content: "*"; color: #FF0000; font-weight: bold; }
        .sweeper-cell.flagged::before { content: "P"; color: #FFFF00; font-weight: bold; }
        .number-1 { color: #00FFFF; } .number-2 { color: #90EE90; } .number-3 { color: #FF4500; }
        .number-4 { color: #FFFF00; } .number-5 { color: #FF00FF; } .number-6 { color: #FFA500; }
        .number-7 { color: #DA70D6; } .number-8 { color: #D3D3D3; }

        /* Maze Runner Specific Styles */
        .maze-grid { /* Extends .grid-display */ }
        .maze-cell { /* Extends .grid-cell */ width: 18px; height: 18px; font-size: 12px; }
        .maze-cell.wall { background-color: #002200; }
        .maze-cell.path { background-color: #001000; }
        .maze-cell.player::before { content: "@"; color: #00FF00; font-weight: bold; z-index: 1; }
        .maze-cell.key::before { content: "$"; color: #FFFF00; font-weight: bold; z-index: 1;}
        .maze-cell.key-collected::before { content: "$"; color: #555500; z-index: 1;} /* Dim collected key */
        .maze-cell.finish::before { content: "F"; color: #00FFFF; font-weight: bold; z-index: 1;}
        .maze-cell.finish-locked::before { content: "F"; color: #005555; z-index: 1;} /* Dim locked finish */
        .maze-cell.decision-point-marker::after { /* Visual cue for decision points */
            content: '';
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #007700; /* A slightly darker green for subtlety */
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #maze-info { margin-bottom: 10px; font-size: 0.9em; }


        /* ASCII Galaga Specific Styles */
        #galaga-area {
            /* size the frame so 40 text columns fit perfectly */
            width: calc(40ch + 5px);      /* 40 = screenWidthChars; +2px = the 1-pixel border on each side */
            height: calc(35em * 0.75);    /* 20 rows * line-height ≈ 0.55em per row → matches char grid */
            margin: 0 auto;               /* centre inside #game-specific-area */
            
            display: flex;                /* centre the <pre> inside the frame */
            justify-content: center;
            align-items: center;

            background-color: #000500;
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color) inset;  /* optional CRT glow */
            
            font-family: var(--font-family);
            font-size: 16px;
            line-height: 1.1;
            color: var(--primary-color);
            overflow: hidden;
            box-sizing: border-box;
            user-select: none;
        }
        #galaga-area pre {
            white-space: pre;
            margin: 0;
            width: 100%;
            height: 100%;
            -webkit-user-select: none;   /* Safari/Chrome */
            -webkit-touch-callout: none; /* stops Google-Lens pop-up */
            user-select: none;           /* everyone else  */
        }
         #galaga-info { margin-bottom: 10px; font-size: 0.9em; }

         /* ==== PROGRESS-BAR WIDGETS ==== */
        #progress-bar-area{
            display:flex;
            gap:22px;
            align-items:flex-end;
            margin-top:6px;
        }
        .progress-wrapper{
            display:flex;
            flex-direction:column;
            align-items:center;
            user-select:none;
        }
        .progress-bar{
            width:24px;
            height:140px;
            border:1px solid var(--border-color);
            background:#002000;
            position:relative;
            overflow:hidden;
            box-shadow:0 0 6px #008000 inset;
        }

        /* common FILL base */
        .progress-bar .progress-fill{
            position:absolute;
            bottom:0;
            width:100%;
            height:0;           /* grows via JS */
            transition:height .4s ease-out;
        }

        /* ---- cycle: “black liquid & stars” ---- */
        .cycle-fill{
            background:#000;
        }
        .cycle-fill::before{
            content:"************************************************";
            position:absolute;
            width:100%;  height:220%;
            left:0; top:-100%;
            font-size:7px;
            line-height:7px;
            color:#ff0080;
            animation:starFloat 8s linear infinite;
            text-align:center;
        }
        @keyframes starFloat{
            0%{transform:translateY(0)}
            100%{transform:translateY(100%)}
        }

        /* ===== SCORE-DELTA BURST ===== */
        @keyframes pulseScore {
        0%   { transform: scale(0.5); opacity: 0; }
        35%  { transform: scale(1.6); opacity: 1; }
        60%  { transform: scale(1.0); }
        100% { opacity: 1; }
        }

        .score-delta {
        color: #00FF00;                /* neon green */
        display: inline-block;
        font-family: var(--font-family);
        font-size: 1.8em;
        font-weight: bold;
        letter-spacing: 1px;
        text-shadow: 0 0 6px #00FF00, 0 0 12px #00FF00;
        opacity: 0;                    /* shown via animation */
        }
        .score-delta.animate {
        animation: pulseScore 1.2s cubic-bezier(.14,1,.3,1) forwards;
        }

        /* ---- wave: Matrix stream ---- */
        .wave-fill{
            background:#001500;
        }
        .wave-fill::before{
            content:"010110001101001011001100101";
            position:absolute;
            width:100%; height:200%;
            left:0; top:-100%;
            font-size:9px;
            line-height:9px;
            color:#00ff00;
            opacity:.8;
            writing-mode:vertical-rl;
            text-orientation:upright;
            animation:matrixScroll 3s linear infinite;
        }
        @keyframes matrixScroll{
            to{transform:translateY(100%)}
        }

        .progress-fraction{
            margin-top:4px;
            font-size:.8em;
            color:var(--primary-color);
            text-shadow:0 0 2px var(--primary-color);
        }
        #fork-overlay {
            position: fixed;
            inset: 0;
            background: #000900 url('data:image/svg+xml,%3Csvg xmlns%3D%22http%3A//www.w3.org/2000/svg%22 width%3D%22100%25%22 height%3D%22100%25%22%3E%3Cdefs%3E%3ClinearGradient id%3D%22g%22 x1%3D%220%22 x2%3D%220%22 y1%3D%220%22 y2%3D%221%22%3E%3Cstop offset%3D%220%25%22 stop-color%3D%22%23002200%22/%3E%3Cstop offset%3D%22100%25%22 stop-color%3D%22%23000000%22/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width%3D%22100%25%22 height%3D%22100%25%22 fill%3D%22url(%23g)%22/%3E%3C/svg%3E') repeat;
            display: none;
            z-index: 1200;
            padding: 40px 25px;
            box-sizing: border-box;
            overflow: auto;
            text-align: center;
        }
        #fork-overlay h2{
            font-size:2em; margin-bottom:25px;
            color:#00FF80; text-shadow:0 0 6px #00FF80;
        }
        .path-gallery{
            display:flex; flex-wrap:wrap; gap:30px; justify-content:center;
        }
        .game-card{
            width:200px;          /* narrower */
            background:#001300;
            border:2px solid #007700;
            border-radius:10px;
            box-shadow:0 0 12px #009900 inset,0 0 6px #003300;
            padding:14px 14px 10px;
            cursor:pointer;
            display:flex;
            flex-direction:column;
            align-items:center;
            transition:transform .25s, box-shadow .25s;
        }
        .game-card:hover{
            transform:scale(1.05);
            box-shadow:0 0 14px #00FF00;
        }
        .game-card img{
            width:100%;
            aspect-ratio:4/3;     /* keeps them short */
            object-fit:cover;
            margin-bottom:6px;
            border:1px solid #004400;
        }
        .card-title{      font-size:1.1em; margin-bottom:4px; }
        .card-difficulty{ font-size:.85em; margin-bottom:6px;}
        .card-how{        font-size:.8em;  line-height:1.3;}

        /* ——— Root Circuit: Start/End styling ——— */
        .rc-start {
        background-color: #04A5FF !important;    /* bright green */
        cursor: default;                          /* non-rotatable */
        }
        .rc-end {
        background-color: #ff0000 !important;    /* bright red */
        cursor: default;
        }

        /* ================= MOBILE (≤600 px) ================= */
        @media (max-width:600px){
            body            { padding:10px; }
            #arcade-shell   { width:100%; max-width:none; padding:10px; }
            h1              { font-size:1.25em; margin-bottom:8px; }
            h2,h3           { font-size:1em;  }
            #global-info-panel{ flex-direction:column; font-size:.9em; }
            .progress-bar   { height:90px; width:20px; }
            #game-specific-area{ min-height:300px; }
            #overlay-content{ max-width:100%; font-size:.85em; padding:16px 18px; }
        }


    </style>
</head>
<body>
    <div id="arcade-shell">
        <div id="header">
            <h1>MinMin [grdn_OS]</h1>
        </div>

        <div id="global-info-panel">
            <span>Cycle: <span id="cycle-display">1</span></span>
            <span>Total Score: <span id="total-score-display">0</span></span>
            <span>Current Game: <span id="current-game-display">-</span></span>

            <!-- ▼ Progress Bars -->
            <div id="progress-bar-area">
                <!-- CYCLE BAR -->
                <div class="progress-wrapper">
                    <div id="cycle-bar"   class="progress-bar">
                        <div id="cycle-fill" class="cycle-fill"></div>
                    </div>
                    <span id="cycle-label" class="progress-fraction">0 / 5</span>
                </div>
            
                <!-- WAVE BAR -->
                <div class="progress-wrapper">
                    <div id="wave-bar"   class="progress-bar">
                        <div id="wave-fill"  class="wave-fill"></div>
                    </div>
                    <span id="wave-label"  class="progress-fraction">0 / 3</span>
                </div>
            </div>
            <!-- ▲ Progress Bars -->
  
        </div>

        <div id="game-specific-area">
            <!-- Game content will be loaded here by JavaScript -->
            <p>Initializing systems...</p>
        </div>
        
        <div id="game-specific-info-area" style="text-align: center; margin-bottom:10px;">
             <!-- Game specific status like timer, keys etc. -->
        </div>


        <div id="log-area-container">
            <pre id="log-display">> SYSTEM LOG INITIATED <<\n</pre>
        </div>

        <div id="overlay" style="display:none;"> <!-- Initially hidden -->
            <div id="overlay-content">
                <h2 id="overlay-title">SYSTEM BOOT</h2>
                <pre id="boot-sequence-display" style="text-align: left; white-space: pre-wrap;"></pre>
                <pre id="overlay-console-text"></pre>
                <div id="overlay-transition-info" style="white-space:pre-wrap; margin-bottom:15px;"></div>
                <div id="choice-gallery" class="path-gallery" style="display:none;"></div>
                <button id="overlay-action-btn">INITIATE SWEEP</button>
            </div>
        </div>
        
    </div>

    <script>

        /* ----------- mobile helpers ----------- */
        const isMobile = matchMedia('(pointer: coarse)').matches;     // true on phones/tablets
        const tapOpts  = { passive: true };                           // shorthand
        const tapBlock = { passive: false };

        const ArcadeManager = {
            currentCycle: 1,
            currentGameIndex: 0, // 0: Maze, 1: Sweeper, 2: Galaga
            totalScore: 0,

            GAMES_PER_CYCLE: 3,
            playsThisCycle: 0,
            MAX_CYCLES: 5,
            
            gameModules: [], // Will hold [MazeGame, SweeperGame, GalagaGame]

            availableGames: [],          // remaining choices this cycle
 
            dom: {
                overlayTransitionInfo: document.getElementById('overlay-transition-info'),
                cycleDisplay: document.getElementById('cycle-display'),
                totalScoreDisplay: document.getElementById('total-score-display'),
                currentGameDisplay: document.getElementById('current-game-display'),
                gameSpecificArea: document.getElementById('game-specific-area'),
                gameSpecificInfoArea: document.getElementById('game-specific-info-area'),
                logDisplay: document.getElementById('log-display'),
                overlay: document.getElementById('overlay'),
                overlayTitle: document.getElementById('overlay-title'),
                overlayConsoleText: document.getElementById('overlay-console-text'),  // ← new
                overlayActionBtn: document.getElementById('overlay-action-btn'),
                bootSequenceDisplay: document.getElementById('boot-sequence-display'),
                cycleFill  : document.getElementById('cycle-fill'),
                waveFill   : document.getElementById('wave-fill'),
                cycleLabel : document.getElementById('cycle-label'),
                waveLabel  : document.getElementById('wave-label'),
            },

            init() {
                this.log("ArcadeManager initializing...");
                this.gameModules = [MazeGame, SweeperGame, GalagaGame, RootCircuitGame]; // Order matters
                this.availableGames = [...this.gameModules];   // reset full list each new sequence
                this.dom.overlayActionBtn.onclick = () => this.startGameSequence();
                this.showBootScreen();
            },

            showBootScreen() {

                /* ─── reset overlay state ─── */
                this.dom.overlay.classList.remove('console-mode');
                this.dom.overlayTransitionInfo.style.display = 'none';
                this.dom.overlayTransitionInfo.textContent   = '';
                this.dom.overlayConsoleText.style.display    = 'block';

                this.dom.overlay.style.display = 'flex';
                this.dom.overlayTitle.textContent = "SYSTEM BOOT";
                this.dom.bootSequenceDisplay.style.display = 'block';

                //this.dom.overlayTransitionInfo.textContent = "";
                this.dom.overlayConsoleText.innerHTML = '';

                this.dom.overlayActionBtn.textContent = "INITIATE SEQUENCE";
                this.dom.overlayActionBtn.style.display = 'none'; // Shown after typing

                const bootMsg = `> BOOTING grdn_OS v3.1…
> Initializing Multi-Path Environment... [OK]
> Calibrating Cycle Progression Matrix... [OK]
> Loading Game Modules:
>  - MAZE_RUNNER.MOD (v1.1)..... [LOADED]
>  - GRID_SWEEPER.MOD .......... [LOADED]
>  - ASTRO_GARDEN.MOD .......... [LOADED]
>  - ROOT_CIRCUIT.MOD .......... [LOADED]
> WELCOME, OPERATIVE.
> OBJECTIVE: Resolve 5 cycle anomalies of increasing complexity.
> Each cycle in grdn_OS contains 3 paths to resolve.
>
> Press 'INITIATE SEQUENCE' to begin.`;
                
                // animate into the console-text area
                this.typeMessage(
                    this.dom.overlayConsoleText,
                    bootMsg,
                    () => { this.dom.overlayActionBtn.style.display = 'block' }
                );
            },

            typeMessage(element, message, callback, index = 0, speed = 20) {
                if (index < message.length) {
                    element.innerHTML += message[index] === '\n' ? '<br>' : message[index];
                    element.scrollTop = element.scrollHeight;
                    setTimeout(() => this.typeMessage(element, message, callback, index + 1, speed), speed);
                } else {
                    element.innerHTML = element.innerHTML.replace(/<span class="blinking-cursor">_<\/span>$/, ''); // Remove cursor
                    if (callback) callback();
                }
            },
            
            startGameSequence() {
                this.currentCycle = 1;
                this.playsThisCycle = 0;
                this.totalScore = 0;
                this.lastScoreDelta = 0;
                this.updateGlobalUI();
                this.log("New game sequence started.");

                // Ensure the overlay is in “console” style without previous boot text
                this.dom.overlay.classList.add('console-mode');
                this.dom.bootSequenceDisplay.style.display = 'none';
                this.dom.overlayConsoleText.style.display = 'block';
                this.dom.overlayConsoleText.innerHTML = ''; 
                this.dom.overlayTitle.textContent = "CHOOSE YOUR PATH";

                // Write a short prompt and then show two-game fork
                const prompt = "Select any of the two games below to begin.";
                this.typeMessage(
                this.dom.overlayConsoleText,
                prompt + "\n\n",
                () => this.showFork()
                );
            },

            loadNextGame() {
                this.dom.overlay.style.display = 'none';
                this.dom.gameSpecificArea.innerHTML = ""; // Clear previous game
                this.dom.gameSpecificInfoArea.innerHTML = ""; // Clear previous game info

                if (this.currentGameIndex >= this.gameModules.length) { // Cycle complete
                    this.currentCycle++;
                    this.currentGameIndex = 0;
                    if (this.currentCycle > this.MAX_CYCLES) {
                        this.overallWin();
                        return;
                    }
                    this.showTransitionScreen(true, this.lastScoreDelta); // True for start of new cycle
                } else {
                    this.showTransitionScreen(false, this.lastScoreDelta);
                }
            },

            startCurrentGame() {
                this.dom.overlay.style.display = 'none';
                const gameModule = this.gameModules[this.currentGameIndex];
                this.dom.currentGameDisplay.textContent = gameModule.name;
                this.log(`Starting Game: ${gameModule.name}, Cycle: ${this.currentCycle}`);

                gameModule.init(
                    this.dom.gameSpecificArea,
                    this.dom.gameSpecificInfoArea,
                    this.currentCycle,
                    {
                        onWin: (scoreEarned) => this.handleGameWin(scoreEarned),
                        onLoss: (reason) => this.handleGameLoss(reason),
                        addToLog: (msg) => this.log(`[${gameModule.name}] ${msg}`),
                        updateTotalScore: (points) => { 
                           this.totalScore += points;
                           this.updateGlobalUI();
                        }
                    }
                );
                gameModule.start();
            },

            showTransitionScreen(isNewCycle, scoreDelta = 0, afterTypingCallback = null) {

                // 1) show overlay, hide boot log
                this.dom.overlay.style.display = 'flex';
                this.dom.bootSequenceDisplay.style.display = 'none';

                // 2) build title & message
                let title, message;
                if (isNewCycle) {
                    title   = `CYCLE ${this.currentCycle - 1} COMPLETE`;
                    message = `Total Score: ${this.totalScore}\n\n` +
                            `Starting Cycle ${this.currentCycle}/5.\n`;
                } else {
                    title   = `PREPARING NEXT CHALLENGE`;
                    message = `Total Score: ${this.totalScore}\n\n` +
                            `Cycle ${this.currentCycle}/5 continues.\n`;
                }

                // 3) colour‐code the heading
                if      (title.includes('COMPLETE')) this.dom.overlayTitle.style.color = '#00FF00';
                else if (title.includes('FAILED'))   this.dom.overlayTitle.style.color = '#FF0040';
                else                                 this.dom.overlayTitle.style.color = '#00A0FF';

                // 4) prepend score delta if any
                if (scoreDelta > 0) {
                    message = `+${scoreDelta}\n` + message;
                }

                // 5) set title
                this.dom.overlayTitle.textContent = title;

                // 6) switch into console mode & clear old text
                this.dom.overlay.classList.add('console-mode');
                this.dom.overlayConsoleText.innerHTML = '';
                this.dom.overlayActionBtn.style.display = 'none';

                // 7) prepare plain‐text typing string (no <span> tags)
                const typingString = message + '\n\nChoose your PATH to proceed.';

                // 8) type it out
                this.typeMessage(
                    this.dom.overlayConsoleText,
                    typingString,
                    () => {
                        // once done, append a real <span> blinking cursor
                        const cursor = document.createElement('span');
                        cursor.classList.add('blinking-cursor');
                        cursor.textContent = '_';
                        this.dom.overlayConsoleText.appendChild(cursor);

                        // show & wire up the button
                        this.dom.overlayActionBtn.style.display = 'block';
                        this.dom.overlayActionBtn.textContent = 'CONTINUE';
                        this.dom.overlayActionBtn.onclick = () => this.startCurrentGame();

                        if (afterTypingCallback) afterTypingCallback();
                    }
                );

                // reset for next time
                this.lastScoreDelta = 0;
            },

            showFork() {
                /* where to inject */
                const gallery = document.getElementById('choice-gallery');
                gallery.style.display = 'flex';
                gallery.innerHTML = '';

                /* ✧ get 2 random games ≠ last played */
                const lastPlayed = this.gameModules[this.currentGameIndex];
                const pool = this.gameModules.filter(g => g !== lastPlayed);
                pool.sort(() => Math.random() - 0.5);       // shuffle
                const choices = pool.slice(0, 2);

                /* build the cards */
                choices.forEach(mod => {
                    const meta = GameMeta[mod.name.replace(/\s+/g,'')];
                    const card = document.createElement('div');
                    card.className = 'game-card';
                    card.innerHTML = `
                        <img src="${meta.thumb}" alt="">
                        <div class="card-title">${mod.name}</div>
                        <div class="card-difficulty">${meta.difficultyName(this.currentCycle)}</div>
                        <div class="card-how">${meta.shortHow.replace(/\n/g,'<br>')}</div>`;
                    card.onclick = () => {
                        gallery.style.display = 'none';      // hide gallery
                        this.currentGameIndex = this.gameModules.indexOf(mod);
                        this.startCurrentGame();
                    };
                    gallery.appendChild(card);
                });

                /* hide the CONTINUE button & extra text */
                this.dom.overlayActionBtn.style.display = 'none';
                this.dom.overlayTransitionInfo.style.display = 'none';
            },

            updateGlobalUI() {
                this.dom.cycleDisplay.textContent  = this.currentCycle;
                this.dom.totalScoreDisplay.textContent = this.totalScore;

                this.updateProgressBars();          // ▼ new
            },

            updateProgressBars() {
                /* CYCLE bar – fills once a cycle is finished */
                const cyclePct = (this.currentCycle) / this.MAX_CYCLES * 100;
                this.dom.cycleFill.style.height = cyclePct + '%';
                this.dom.cycleLabel.textContent = `${this.currentCycle}/${this.MAX_CYCLES}`;

                /* WAVE bar – fills as games are cleared this cycle */
                const wavePct = this.playsThisCycle / this.GAMES_PER_CYCLE * 100;
                this.dom.waveFill.style.height  = wavePct + '%';
                this.dom.waveLabel.textContent  = `${this.playsThisCycle}/${this.GAMES_PER_CYCLE}`;
            },


            handleGameWin(scoreEarnedThisGame) {
                this.lastScoreDelta  = scoreEarnedThisGame;
                this.totalScore     += scoreEarnedThisGame;
                this.playsThisCycle += 1;
                this.updateGlobalUI();

                const played = this.gameModules[this.currentGameIndex];

                if (this.playsThisCycle >= this.GAMES_PER_CYCLE) {
                    // end of cycle
                    this.playsThisCycle = 0;
                    this.currentCycle++;

                    if (this.currentCycle > this.MAX_CYCLES) {
                        this.overallWin();
                        return;
                    }

                    this.showTransitionScreen(
                        true,
                        scoreEarnedThisGame,
                        () => this.showFork()
                    );
                } else {
                    // still within the same cycle
                    this.showTransitionScreen(
                        false,
                        scoreEarnedThisGame,    // ← now correctly passed
                        () => this.showFork()
                    );
                }

                if (played.end) {
                    played.end();
                }
            },

            handleGameLoss(reason) {
                this.log(`Game ${this.gameModules[this.currentGameIndex].name} LOST: ${reason}`);

                // Shut the current mini-game down cleanly
                if (this.gameModules[this.currentGameIndex].end) {
                    this.gameModules[this.currentGameIndex].end();
                }

                /* ---------- build failure summary ---------- */
                const summary = [
                    `Reason: ${reason}`,
                    `Total Score: ${this.totalScore}`,
                    `Reached Cycle: ${this.currentCycle}`,
                    `Failed Game: ${this.gameModules[this.currentGameIndex].name}`
                ].join('\n');

                /* ---------- show overlay ---------- */
                const d = this.dom;
                d.overlay.style.display = 'flex';
                d.overlay.classList.remove('console-mode');     // plain neon panel
                d.overlayTitle.textContent = 'SEQUENCE FAILED';

                d.bootSequenceDisplay.style.display   = 'none';
                d.overlayConsoleText.style.display    = 'none';
                d.overlayTransitionInfo.style.display = 'block';
                d.overlayTransitionInfo.textContent   = summary;

                /* ---------- restart button ---------- */
                d.overlayActionBtn.style.display = 'block';
                d.overlayActionBtn.textContent   = 'RESTART SEQUENCE';
                d.overlayActionBtn.onclick = () => this.init();

            },

            overallWin() {
                this.log("All cycles complete! VICTORY!");
                this.dom.overlay.style.display = 'flex';
                this.dom.overlayTitle.textContent = "SEQUENCE MASTERED!";
                this.dom.bootSequenceDisplay.style.display = 'none';
                this.dom.overlayTransitionInfo.innerHTML = `Congratulations, Operative! You have mastered all ${this.MAX_CYCLES} cycles!<br>Final Score: ${this.totalScore}`;
                this.dom.overlayActionBtn.textContent = "REPLAY";
                this.dom.overlayActionBtn.onclick = () => this.init();
            },

            log(message) {
                console.log(message);
                const time = new Date().toLocaleTimeString();
                this.dom.logDisplay.innerHTML += `[${time}] ${message}\n`;
                this.dom.logDisplay.scrollTop = this.dom.logDisplay.scrollHeight;
            }
        };

        /* ---------- GAME REGISTRY ---------- */
        const GameMeta = {
            MazeRunner : {
                thumb : 'assets/maze.png',
                shortHow: 'Slide with ↑↓←→ until you hit a wall or junction.\nGrab all keys, then reach the F.',
                difficultyName(cycle){ return ['Sprout','Sapling','Stalk','Bloom','Elder'][cycle-1]; }
            },
            GridSweeper: {
                thumb : 'assets/sweeper.png',
                shortHow: 'Reveal safe tiles, flag mines (right-click).\nFirst click is always safe.',
                difficultyName(cycle){ return ['Pebble','Stone','Boulder','Cliff','Mountain'][cycle-1]; }
            },
            AstroGarden: {
                thumb : 'assets/astra.png',
                shortHow: '←/→ to move, Space to shoot.\nHit score before timer ends.',
                difficultyName(cycle){ return ['Orbit I','Orbit II','Orbit III','Nebula','Supernova'][cycle-1]; }
            },
            RootCircuit: {
                thumb: 'assets/root.png',
                shortHow: 'Rotate tiles to connect a path from top to bottom.\nComplete before the circuit pulses!',
                difficultyName(cycle) { return ['Boot', 'Flow', 'Pulse', 'Surge', 'Overload'][cycle-1]; }
            },
            /* ✧ add future modules here the same way */
        };


        // --- Maze Runner Game Module (v1.1 - Decision Points Update) ---
        const MazeGame = {
            name: "Maze Runner",
            container: null,
            infoContainer: null,
            cycle: 1,
            callbacks: null,
            maze: [], // Will be array of cell objects: {isWall, isKey, isFinish, isDecisionPoint, keyCollected}
            player: { r: 0, c: 0 },
            keysToCollect: 0,
            keysCollected: 0,
            finish: { r: 0, c: 0, locked: true },
            timerId: null,
            timeLeft: 0,
            config: {
                cellSize: 18, 
                sizes: [ {w:7, h:7}, {w:9, h:9}, {w:11, h:11}, {w:13, h:13}, {w:15, h:15} ], 
                numKeys: [2, 3, 4, 5, 6],
                times: [25, 30, 35, 40, 45] // Increased times slightly
            },
            gridElement: null,

            init(container, infoContainer, cycle, callbacks) {
                this.container = container;
                this.infoContainer = infoContainer;
                this.cycle = cycle;
                this.callbacks = callbacks;
                
                const cycleConfigIndex = Math.min(cycle - 1, this.config.sizes.length - 1);
                this.mazeWidth = this.config.sizes[cycleConfigIndex].w * 2 + 1;
                this.mazeHeight = this.config.sizes[cycleConfigIndex].h * 2 + 1;
                this.keysToCollect = this.config.numKeys[cycleConfigIndex];
                this.timeLeft = this.config.times[cycleConfigIndex];
                this.keysCollected = 0;
                this.finish.locked = true;

                this.container.innerHTML = `<div id="maze-runner-grid" class="grid-display maze-grid"></div>`;
                this.gridElement = document.getElementById('maze-runner-grid');
                this.updateInfo();
                this.generateMaze();
            },

            start() {
                this.callbacks.addToLog("Maze Runner started. Use arrow keys to move.");
                document.addEventListener('keydown', this.handleKey);
                
                if (isMobile){
                    let sx=0, sy=0;
                    const Z = this.container;                 // bigger hit-box
                    Z.addEventListener('touchstart', e=>{
                        const t=e.touches[0]; sx=t.clientX; sy=t.clientY;
                    }, tapOpts);
                    Z.addEventListener('touchend', e=>{
                        const t=e.changedTouches[0];
                        const dx=t.clientX-sx, dy=t.clientY-sy;
                        const absX=Math.abs(dx), absY=Math.abs(dy);
                        if (absX<30 && absY<30) return;       // shrug tiny drags
                        const key = absX>absY
                            ? (dx>0?'ArrowRight':'ArrowLeft')
                            : (dy>0?'ArrowDown':'ArrowUp');
                        this.handleKey({ key });
                    }, tapOpts);
                }
                                
                this.timerId = setInterval(() => {
                    if (this.timeLeft <= 0) return; // Prevent timer from going negative if game ends before interval fires
                    this.timeLeft--;
                    this.updateInfo();
                    if (this.timeLeft <= 0) {
                        this.gameOver("Time ran out!");
                    }
                }, 1000);
                this.renderMaze();
            },

            end() {
                /* halt timers / listeners exactly as before */
                clearInterval(this.timerId);
                this.timerId = null;

                /* remove any keys / events this module added */
                document.removeEventListener('keydown', this.handleKey);
                document.removeEventListener('keyup',   this.handleKey);   // Galaga needs this

                /* log only if callbacks are wired */
                if (this.callbacks && this.callbacks.addToLog) {
                    this.callbacks.addToLog(`${this.name || 'Game'} ended.`);
                }
                this.callbacks = null;   // mark inactive for safety
            },
            
            updateInfo() {
                this.infoContainer.innerHTML = `<div id="maze-info">Time: ${this.timeLeft}s | Keys: ${this.keysCollected}/${this.keysToCollect}</div>`;
            },

            generateMaze() {
                // 1 build a wall matrix (1 = wall, 0 = path) with recursive back-tracker
                const numberMaze = Array(this.mazeHeight).fill(null)
                    .map(() => Array(this.mazeWidth).fill(1));

                const carve = (r, c) => {
                    numberMaze[r][c] = 0;
                    const dirs = [[0, 2], [2, 0], [0, -2], [-2, 0]].sort(() => Math.random() - 0.5);
                    for (const [dr, dc] of dirs) {
                        const nr = r + dr, nc = c + dc, wr = r + dr / 2, wc = c + dc / 2;
                        if (nr > 0 && nr < this.mazeHeight - 1 && nc > 0 && nc < this.mazeWidth - 1
                            && numberMaze[nr][nc] === 1) {
                            numberMaze[wr][wc] = 0;
                            carve(nr, nc);
                        }
                    }
                };
                carve(1, 1);

                // 2 convert to object grid + mark decision points
                this.maze = Array(this.mazeHeight).fill(null)
                    .map(() => Array(this.mazeWidth).fill(null));

                const DIRS = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // U, D, L, R

                for (let r = 0; r < this.mazeHeight; r++) {
                    for (let c = 0; c < this.mazeWidth; c++) {
                        const isWall = numberMaze[r][c] === 1;

                        const cell = this.maze[r][c] = {
                            isWall,
                            isKey: false,
                            isFinish: false,
                            isDecisionPoint: false,
                            keyCollected: false
                        };

                        if (isWall) continue;

                        // ── neighbour scan ──
                        const open = [false, false, false, false];
                        let paths = 0;
                        DIRS.forEach(([dr, dc], idx) => {
                            const nr = r + dr, nc = c + dc;
                            if (nr >= 0 && nr < this.mazeHeight &&
                                nc >= 0 && nc < this.mazeWidth &&
                                numberMaze[nr][nc] === 0) {
                                open[idx] = true;
                                paths++;
                            }
                        });

                        /* decision-point test:
                        ⋆ 3+ exits  → always junction
                        ⋆ 2 exits   → mark **only** if at least one vertical AND one horizontal exit   */
                        const perpendicular = (open[0] || open[1]) && (open[2] || open[3]);
                        if (paths >= 3 || (paths === 2 && perpendicular)) {
                            cell.isDecisionPoint = true;
                        }
                    }
                }

                // 3 player start guarantees path
                this.player = { r: 1, c: 1 };
                if (this.maze[1][1].isWall) this.maze[1][1].isWall = false;
                this.maze[1][1].isDecisionPoint = false; // never stop on the spawn tile

                // 4 place keys
                for (let i = 0; i < this.keysToCollect; i++) {
                    let kr, kc;
                    do {
                        kr = 1 + Math.floor(Math.random() * (this.mazeHeight - 2));
                        kc = 1 + Math.floor(Math.random() * (this.mazeWidth  - 2));
                    } while (this.maze[kr][kc].isWall || this.maze[kr][kc].isKey ||
                            (kr === this.player.r && kc === this.player.c));
                    this.maze[kr][kc].isKey = true;
                }

                // 5 place finish
                do {
                    this.finish = {
                        r: 1 + Math.floor(Math.random() * (this.mazeHeight - 2)),
                        c: 1 + Math.floor(Math.random() * (this.mazeWidth  - 2)),
                        locked: true
                    };
                } while (this.maze[this.finish.r][this.finish.c].isWall ||
                        this.maze[this.finish.r][this.finish.c].isKey ||
                        (this.finish.r === this.player.r && this.finish.c === this.player.c));
                this.maze[this.finish.r][this.finish.c].isFinish = true;
            },

            renderMaze() {
                this.gridElement.innerHTML = '';
                this.gridElement.style.gridTemplateColumns = `repeat(${this.mazeWidth}, ${this.config.cellSize}px)`;
                this.gridElement.style.gridTemplateRows = `repeat(${this.mazeHeight}, ${this.config.cellSize}px)`;

                for (let r = 0; r < this.mazeHeight; r++) {
                    for (let c = 0; c < this.mazeWidth; c++) {
                        const cellDiv = document.createElement('div');
                        cellDiv.classList.add('grid-cell', 'maze-cell');
                        const cellData = this.maze[r][c];

                        if (cellData.isWall) cellDiv.classList.add('wall');
                        else cellDiv.classList.add('path');

                        if (r === this.player.r && c === this.player.c) cellDiv.classList.add('player');
                        
                        if (cellData.isKey) {
                            cellDiv.classList.add('key');
                            if (cellData.keyCollected) cellDiv.classList.add('key-collected');
                        }

                        if (cellData.isFinish) {
                            cellDiv.classList.add('finish');
                            if (this.finish.locked) cellDiv.classList.add('finish-locked');
                        }
                        if (cellData.isDecisionPoint && !cellData.isWall && !(r === this.player.r && c === this.player.c) && !cellData.isKey && !cellData.isFinish) {
                            cellDiv.classList.add('decision-point-marker');
                        }
                        this.gridElement.appendChild(cellDiv);
                    }
                }
            },

            handleKey: (e) => {
                /* 1. suppress native scrolling *only* if the real event
                    object actually owns preventDefault()                */
                if (e.preventDefault) e.preventDefault();

                /* 2. ignore input once the timer has stopped              */
                if (!MazeGame.timerId || MazeGame.timeLeft <= 0) return;

                /* 3. translate key → movement vector                      */
                let dr = 0, dc = 0;
                switch (e.key) {
                    case 'ArrowUp':    dr = -1; break;
                    case 'ArrowDown':  dr =  1; break;
                    case 'ArrowLeft':  dc = -1; break;
                    case 'ArrowRight': dc =  1; break;
                    default: return;                  // anything else → bail out
                }

                /* ------------------------------------------------------------------
                SLIDE UNTIL WALL / DECISION-POINT
                ------------------------------------------------------------------ */
                const { r: initialR, c: initialC } = MazeGame.player;
                let slidedToR = initialR, slidedToC = initialC;

                while (true) {
                    const nextStepR = slidedToR + dr;
                    const nextStepC = slidedToC + dc;

                    // 1. grid edge
                    if (nextStepR < 0 || nextStepR >= MazeGame.mazeHeight ||
                        nextStepC < 0 || nextStepC >= MazeGame.mazeWidth) {
                        break;
                    }

                    const nextCell = MazeGame.maze[nextStepR][nextStepC];

                    // 2. barrier (wall)
                    if (nextCell.isWall) break;

                    // 3. advance slide
                    slidedToR = nextStepR;
                    slidedToC = nextStepC;
                    const cellPlayerIsOn = nextCell;

                    // 4. key pickup
                    if (cellPlayerIsOn.isKey && !cellPlayerIsOn.keyCollected) {
                        cellPlayerIsOn.keyCollected = true;
                        MazeGame.keysCollected++;
                        MazeGame.callbacks.addToLog(
                            `Collected key (${MazeGame.keysCollected}/${MazeGame.keysToCollect})`
                        );
                        if (MazeGame.keysCollected === MazeGame.keysToCollect) {
                            MazeGame.finish.locked = false;
                            MazeGame.callbacks.addToLog("All keys collected! Finish unlocked.");
                        }
                        MazeGame.updateInfo();
                    }

                    // 5. finish check
                    if (cellPlayerIsOn.isFinish) {
                        if (MazeGame.keysCollected === MazeGame.keysToCollect) {
                            MazeGame.player = { r: slidedToR, c: slidedToC };
                            MazeGame.gameWon();
                            return;
                        }
                        // not enough keys yet → keep sliding
                    }

                    // 6. stop at decision-point (but not the starting square)
                    if (cellPlayerIsOn.isDecisionPoint &&
                        (slidedToR !== initialR || slidedToC !== initialC)) {
                        break;
                    }
                }

                /* 7. commit the move & redraw                               */
                MazeGame.player = { r: slidedToR, c: slidedToC };

                if (slidedToR === MazeGame.finish.r &&
                    slidedToC === MazeGame.finish.c &&
                    !MazeGame.finish.locked) {
                    MazeGame.gameWon();
                } else {
                    MazeGame.renderMaze();
                }
            },

            gameWon() {
                if (!this.timerId) return; // Already ended
                this.callbacks.addToLog("Maze cleared!");
                const score = this.timeLeft * 10; // Keys score added globally by ArcadeManager
                this.callbacks.onWin(score); 
            },

            gameOver(reason) {
                if (!this.timerId) return; // Already ended
                this.callbacks.addToLog(`Maze failed: ${reason}`);
                this.callbacks.onLoss(reason);
            }
        };

        // --- Grid Sweeper Game Module (Refactored) ---
        const SweeperGame = {
            name: "Grid Sweeper",
            container: null,
            infoContainer: null,
            cycle: 1,
            callbacks: null,
            gs: {}, // Game State for sweeper
            config: {
                cellSize: 20,
                gridSizes: [6, 8, 12, 16, 22], // Size (N x N)
                minePercentage: 0.12
            },
            gridElement: null,

            init(container, infoContainer, cycle, callbacks) {
                /* ▼ basic wiring -------------------------------------------------- */
                this.container       = container;
                this.infoContainer   = infoContainer;
                this.cycle           = cycle;
                this.callbacks       = callbacks;

                /* ▼ cycle-scaled params ------------------------------------------- */
                const idx          = Math.min(cycle - 1, this.config.gridSizes.length - 1);
                const gridSize     = this.config.gridSizes[idx];

                this.gs = {
                    grid: [],
                    rows: gridSize,
                    cols: gridSize,
                    numMines: Math.floor(gridSize * gridSize * this.config.minePercentage),
                    flagsPlaced: 0,
                    cellsRevealed: 0,
                    totalNonMineCells: 0,
                    gameOver: false,
                    firstClick: true,
                    firstClickCell: { r: -1, c: -1 }
                };

                /* ▼ shell --------------------------------------------------------- */
                this.container.innerHTML =
                    `<div id="sweeper-grid" class="grid-display"></div>`;
                this.gridElement     = document.getElementById('sweeper-grid');

                /* ▼ info panel stub + (mobile) toggle ----------------------------- */
                this.infoContainer.innerHTML =
                    `<div id="sweeper-info"></div>`;              // text only – toggle sits next to it

                this.flagMode = false;                           // ← new flag mode
                if (isMobile) {
                    const toggle = document.createElement('label');
                    toggle.style.fontSize = '.85em';
                    toggle.innerHTML =
                        `<input type="checkbox" id="flag-toggle"> Flag Mode`;
                    this.infoContainer.appendChild(toggle);
                    toggle.querySelector('#flag-toggle')
                        .addEventListener('change', e => {
                            this.flagMode = e.target.checked;
                        }, tapOpts);
                }

                /* ▼ pre-compute & paint grid shell -------------------------------- */
                this.gs.totalNonMineCells =
                    (this.gs.rows * this.gs.cols) - this.gs.numMines;
                this.updateInfo();
                this.renderInitialGridShell();
            },
            
            renderInitialGridShell() { 
                this.gridElement.innerHTML = '';
                this.gridElement.style.gridTemplateColumns = `repeat(${this.gs.cols}, ${this.config.cellSize}px)`;
                this.gridElement.style.gridTemplateRows = `repeat(${this.gs.rows}, ${this.config.cellSize}px)`;

                for (let r = 0; r < this.gs.rows; r++) {
                    this.gs.grid[r] = [];
                    for (let c = 0; c < this.gs.cols; c++) {
                        this.gs.grid[r][c] = { 
                            isMine: false, isRevealed: false, isFlagged: false, adjacentMines: 0
                        };
                        const div = document.createElement('div');
                        div.classList.add('grid-cell', 'sweeper-cell');
                        div.dataset.r = r;
                        div.dataset.c = c;
                        div.addEventListener('click', () => this.handleLeftClick(r, c));
                        div.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            this.handleRightClick(r, c);
                        });
                        this.gridElement.appendChild(div);
                    }
                }
            },

            start() {
                this.callbacks.addToLog("Grid Sweeper started. Click to reveal, Right-click to flag.");
            },
            
            end() {
                 this.callbacks.addToLog("Grid Sweeper ended.");
            },

            // replace SweeperGame.updateInfo() with:
            updateInfo(){
                const lbl = document.getElementById('sweeper-info');
                if (!lbl) return;
                lbl.textContent =
                `Mines: ${this.gs.numMines} | Flags: ${this.gs.flagsPlaced} | `
                + `Revealed: ${this.gs.cellsRevealed}/${this.gs.totalNonMineCells}`;
            },

            setupGridAndMines() { 
                const { r: firstR, c: firstC } = this.gs.firstClickCell;
                
                for (let r_init = 0; r_init < this.gs.rows; r_init++) {
                    for (let c_init = 0; c_init < this.gs.cols; c_init++) {
                        this.gs.grid[r_init][c_init].isMine = false;
                        this.gs.grid[r_init][c_init].adjacentMines = 0;
                    }
                }

                let minesToPlace = this.gs.numMines;
                const safeZone = [];
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                         const nr = firstR + dr;
                         const nc = firstC + dc;
                         if (nr >=0 && nr < this.gs.rows && nc >=0 && nc < this.gs.cols) {
                            safeZone.push(`${nr},${nc}`);
                         }
                    }
                }
                
                let attempts = 0;
                let actualMinesPlaced = 0;
                while (minesToPlace > 0 && attempts < this.gs.rows * this.gs.cols * 2) { 
                    const r = Math.floor(Math.random() * this.gs.rows);
                    const c = Math.floor(Math.random() * this.gs.cols);
                    if (!this.gs.grid[r][c].isMine && !safeZone.includes(`${r},${c}`)) {
                        this.gs.grid[r][c].isMine = true;
                        minesToPlace--;
                        actualMinesPlaced++;
                    }
                    attempts++;
                }
                 if (minesToPlace > 0) this.callbacks.addToLog(`Warning: Could not place all ${this.gs.numMines} mines. Placed ${actualMinesPlaced}.`);
                 this.gs.numMines = actualMinesPlaced; // Update to actual mines on grid.


                for (let r_adj = 0; r_adj < this.gs.rows; r_adj++) {
                    for (let c_adj = 0; c_adj < this.gs.cols; c_adj++) {
                        if (this.gs.grid[r_adj][c_adj].isMine) continue;
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = r_adj + dr;
                                const nc = c_adj + dc;
                                if (nr >= 0 && nr < this.gs.rows && nc >= 0 && nc < this.gs.cols && this.gs.grid[nr][nc].isMine) {
                                    count++;
                                }
                            }
                        }
                        this.gs.grid[r_adj][c_adj].adjacentMines = count;
                    }
                }
                this.gs.totalNonMineCells = (this.gs.rows * this.gs.cols) - this.gs.numMines; 
                this.updateInfo(); 
            },

            renderGrid() { 
                this.gridElement.innerHTML = ''; 
                this.gridElement.style.gridTemplateColumns = `repeat(${this.gs.cols}, ${this.config.cellSize}px)`;
                this.gridElement.style.gridTemplateRows = `repeat(${this.gs.rows}, ${this.config.cellSize}px)`;

                for (let r = 0; r < this.gs.rows; r++) {
                    for (let c = 0; c < this.gs.cols; c++) {
                        const cell = this.gs.grid[r][c];
                        const div = document.createElement('div');
                        div.classList.add('grid-cell', 'sweeper-cell');
                        div.dataset.r = r;
                        div.dataset.c = c;

                        if (cell.isRevealed) {
                            div.classList.add('revealed');
                            if (cell.isMine) {
                                div.classList.add('mine');
                            } else if (cell.adjacentMines > 0) {
                                div.textContent = cell.adjacentMines;
                                div.classList.add(`number-${Math.min(cell.adjacentMines, 8)}`);
                            }
                        } else { 
                            if (cell.isFlagged) {
                                div.classList.add('flagged');
                            }
                        }
                        if (!this.gs.gameOver) {
                            div.addEventListener('click', () => this.handleLeftClick(r, c));
                            div.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                this.handleRightClick(r, c);
                            });
                        }
                        this.gridElement.appendChild(div);
                    }
                }
            },

            handleLeftClick(r, c) {
                if (this.gs.gameOver) return;

                /* ─── Mobile: when “Flag Mode” switch is on, a tap works like a right-click ─── */
                // ┌───────────────────────────────────────────────────────────────────────────┐
                if (isMobile && this.flagMode) {
                    this.handleRightClick(r, c);   // place / remove flag
                    return;                         // skip reveal logic
                }
                // └───────────────────────────────────────────────────────────────────────────┘

                /* ─── Desktop (or mobile in Reveal mode) ─── */
                if (this.gs.firstClick) {
                    this.gs.firstClick = false;
                    this.gs.firstClickCell = { r, c };
                    this.setupGridAndMines();          // build mines away from safe zone
                    this.revealCell(r, c, true);       // good-start flood fill
                    this.renderGrid();
                    return;
                }

                const cell = this.gs.grid[r][c];
                if (cell.isRevealed || cell.isFlagged) return;

                this.revealCell(r, c, false);
                if (!this.gs.gameOver) this.renderGrid();   // skip if reveal ended game
            },
            
            revealCell(r, c, isFirstClickContext = false) { 
                const cell = this.gs.grid[r][c];
                // If already revealed or flagged, or game is over, do nothing
                if (cell.isRevealed || cell.isFlagged || this.gs.gameOver) return;
            
                cell.isRevealed = true;
            
                if (cell.isMine) {
                    this.gameOver("Hit a mine!"); // This will call renderGrid after setting mines
                    return;
                }
            
                this.gs.cellsRevealed++;
                this.callbacks.updateTotalScore(10); 
            
                // Flood fill logic
                if (cell.adjacentMines === 0) {
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            // For regular flood fill, (dr === 0 && dc === 0) means current cell, skip.
                            if (dr === 0 && dc === 0) continue; 
                            const nr = r + dr;
                            const nc = c + dc;
                            if (nr >= 0 && nr < this.gs.rows && nc >= 0 && nc < this.gs.cols) {
                                this.revealCell(nr, nc, false); // Not firstClickContext for recursive calls
                            }
                        }
                    }
                } 
                // If it's the first click context, and the initially clicked cell was a 0,
                // also reveal its direct non-mine neighbors even if they have numbers.
                // This is implicitly handled by the above if adjacentMines === 0, which is guaranteed for first click cell.
                // The guarantee is that the first clicked cell will be a 0, so its neighbors will be revealed by the normal flood fill.
                // If it was NOT a 0, it would be revealed, and its neighbors (if numbers) would not auto-reveal.
                // The core idea of "good start" is the 3x3 safe zone, making the clicked cell a 0.
            
                this.updateInfo();
                this.checkWinCondition(); // This might call gameWon(), which could render.
            },

            handleRightClick(r, c) {
                if (this.gs.gameOver || this.gs.firstClick) return; 
                const cell = this.gs.grid[r][c];
                if (cell.isRevealed) return;

                cell.isFlagged = !cell.isFlagged;
                if (cell.isFlagged) {
                    this.gs.flagsPlaced++;
                    if (cell.isMine) this.callbacks.updateTotalScore(20); 
                    else this.callbacks.updateTotalScore(-10); 
                } else {
                    this.gs.flagsPlaced--;
                }
                this.updateInfo();
                this.renderGrid(); 
            },

            revealAllMines() {
                for (let r_reveal = 0; r_reveal < this.gs.rows; r_reveal++) {
                    for (let c_reveal = 0; c_reveal < this.gs.cols; c_reveal++) {
                        if (this.gs.grid[r_reveal][c_reveal].isMine) {
                            this.gs.grid[r_reveal][c_reveal].isRevealed = true;
                        }
                    }
                }
            },

            checkWinCondition() {
                if (!this.gs.gameOver && this.gs.cellsRevealed === this.gs.totalNonMineCells && this.gs.totalNonMineCells > 0) {
                    this.gameWon();
                }
            },

            gameWon() {
                if(this.gs.gameOver) return; // Prevent multiple calls
                this.gs.gameOver = true; 
                this.callbacks.addToLog("Grid Sweeper map cleared!");
                this.callbacks.updateTotalScore(this.gs.numMines * 30); 
                this.renderGrid(); 
                this.callbacks.onWin(0); 
            },

            gameOver(reason) {
                if(this.gs.gameOver) return; // Prevent multiple calls
                this.gs.gameOver = true; 
                this.callbacks.addToLog(`Grid Sweeper failed: ${reason}`);
                this.revealAllMines();
                this.renderGrid(); 
                this.callbacks.onLoss(reason);
            }
        };

        // --- ASCII Galaga Game Module ---
        const GalagaGame = {
            name: "Astro Garden",
            container: null,
            infoContainer: null,
            cycle: 1,
            callbacks: null,
            config: {
                survivalTime: 35, 
                targetScores: [800, 1000, 1100, 1400, 1600],
                enemyBaseSpeed: [0.05, 0.07, 0.075, 0.08, 0.085], 
                enemySpawnInterval: [1500, 1200, 1000, 900, 800], 
                asteroidSpawnInterval: [2000, 1700, 1400, 1200, 1100],
                screenWidthChars: 40,
                screenHeightChars: 20,
            },
            player: { x: 0, y: 0, char: '^A^', width: 3, vx: 0 },
            keysPressed: {},
            playerSpeed: 0.40,
            bullets: [],
            enemies: [], 
            asteroids: [], 
            score: 0,
            timeLeft: 0,
            targetScore: 0,
            gameLoopId: null,
            spawnTimers: {},
            gameScreen: null, 
            charBuffer: [], 
            isActive: false, 

            init(container, infoContainer, cycle, callbacks) {
                this.container = container;
                this.infoContainer = infoContainer;
                this.cycle = cycle;
                this.callbacks = callbacks;
                this.isActive = false; 

                this.keysPressed     = { left: false, right: false };

                const cIdx = Math.min(cycle - 1, this.config.targetScores.length - 1);
                this.timeLeft = this.config.survivalTime;
                this.targetScore = this.config.targetScores[cIdx];
                this.currentEnemySpeed = this.config.enemyBaseSpeed[cIdx];
                this.currentEnemySpawnInterval = this.config.enemySpawnInterval[cIdx];
                this.currentAsteroidSpawnInterval = this.config.asteroidSpawnInterval[cIdx];
                
                this.score = 0;
                this.bullets = [];
                this.enemies = [];
                this.asteroids = [];
                
                this.player.x = Math.floor(this.config.screenWidthChars / 2) - Math.floor(this.player.width / 2);
                this.player.y = this.config.screenHeightChars - 1;

                this.container.innerHTML = `<div id="galaga-area"><pre id="galaga-screen"></pre></div>`;
                this.gameScreen = document.getElementById('galaga-screen');
                this.updateInfo();
                this.initCharBuffer();
                this.renderGameScreen(); 
            },

            initCharBuffer() {
                this.charBuffer = [];
                for (let i = 0; i < this.config.screenHeightChars; i++) {
                    this.charBuffer[i] = Array(this.config.screenWidthChars).fill(' ');
                }
            },
            
            updateInfo() {
                 this.infoContainer.innerHTML = `<div id="galaga-info">Time: ${this.timeLeft}s | Score: ${this.score} / ${this.targetScore}</div>`;
            },

            start() {

                this.tiltGamma = 0;
                if (isMobile && window.DeviceOrientationEvent){
                    const orientCb = e => { this.tiltGamma = e.gamma || 0; };
                    if (DeviceOrientationEvent.requestPermission){
                        DeviceOrientationEvent.requestPermission().then(p=>{
                            if (p==='granted') window.addEventListener('deviceorientation',orientCb);
                        });
                    }else{
                        window.addEventListener('deviceorientation', orientCb);
                    }
                    /* tap anywhere on frame to shoot */
                    this.touchShootHandler = e => {
                        e.preventDefault();
                        e.stopPropagation();   
                        this.spawnBullet();
                    };
                    this.container.addEventListener('touchstart', this.touchShootHandler, tapBlock);
                }


                this.isActive = true;
                this.callbacks.addToLog("Astro Garden started. Left/Right Arrows to move, Space to shoot.");
                document.addEventListener('keydown', this.handleKeyDown);
                document.addEventListener('keyup',   this.handleKeyUp);
                
                this.spawnTimers.mainLoop = setInterval(() => {
                    if (!this.isActive || this.timeLeft <=0) return;
                    this.timeLeft--;
                    this.updateInfo();
                    if (this.timeLeft <= 0) this.checkGameEnd();
                }, 1000);

                this.spawnTimers.enemy = setInterval(() => { if (this.isActive) this.spawnEnemy(); }, this.currentEnemySpawnInterval);
                this.spawnTimers.asteroid = setInterval(() => { if (this.isActive) this.spawnAsteroid(); }, this.currentAsteroidSpawnInterval);

                this.gameLoopId = requestAnimationFrame(this.gameLoop);
            },

            end() {
                this.isActive = false; 
                if (this.gameLoopId) cancelAnimationFrame(this.gameLoopId);
                this.gameLoopId = null;
                
                Object.values(this.spawnTimers).forEach(timerId => clearInterval(timerId));
                this.spawnTimers = {};

                document.removeEventListener('keydown', this.handleKeyDown);
                document.removeEventListener('keyup',   this.handleKeyUp);
                
                if (this.touchShootHandler) {
                    this.container.removeEventListener('touchstart', this.touchShootHandler, tapBlock);
                    this.touchShootHandler = null;
                }

                this.callbacks.addToLog("Astro Garden ended.");

            },
            
            gameLoop: () => { 
                if (!GalagaGame.isActive) return; 
                GalagaGame.updateGameObjects();
                GalagaGame.checkCollisions(); // This might call gameOver, which sets isActive=false
                if (!GalagaGame.isActive) return; // Re-check after collisions
                GalagaGame.renderGameScreen();
                GalagaGame.gameLoopId = requestAnimationFrame(GalagaGame.gameLoop);
            },

            handleKeyDown(e) {
                if (!GalagaGame.isActive) return;
                if (e.key === 'ArrowLeft')  GalagaGame.keysPressed.left  = true;
                if (e.key === 'ArrowRight') GalagaGame.keysPressed.right = true;
                if (e.key === ' ') { e.preventDefault(); GalagaGame.spawnBullet(); }
            },

            handleKeyUp(e) {
                if (e.key === 'ArrowLeft')  GalagaGame.keysPressed.left  = false;
                if (e.key === 'ArrowRight') GalagaGame.keysPressed.right = false;
            },

            spawnEnemy() {
                const x = Math.floor(Math.random() * (this.config.screenWidthChars - 2)); 
                this.enemies.push({ x, y: 0, char: ' V ', colour:'#04A5FF', width: 3, type:'plant', points:50, speed:this.currentEnemySpeed });
            },
            spawnAsteroid() {
                 const x = Math.floor(Math.random() * this.config.screenWidthChars);
                 this.asteroids.push({ x, y: 0, char: '*', colour:'#FF3030', width:1,type:'asteroid', speed:this.currentEnemySpeed*0.8 });
            },
            spawnBullet() {
                if (this.bullets.length < 5) { 
                    this.bullets.push({x: this.player.drawX + Math.floor(this.player.width / 2), y: this.player.y - 1, prevY: this.player.y - 1, char: '|'});
                }
            },

            updateGameObjects() {

                let vx = 0;

                // tilt first
                if (isMobile){
                    if (this.tiltGamma < -5)      vx = -this.playerSpeed+0.05;
                    else if (this.tiltGamma > 5)  vx =  this.playerSpeed-0.05;
                }

                // keyboard (if pressed) overrides tilt
                if (this.keysPressed.left)       vx = -this.playerSpeed;
                else if (this.keysPressed.right) vx =  this.playerSpeed;

                this.player.vx = vx;

                this.player.x += this.player.vx;
                this.player.x = Math.max(0,
                    Math.min(this.config.screenWidthChars - this.player.width,
                        this.player.x));

                this.player.drawX = Math.round(this.player.x);
                
                this.bullets.forEach(b => {b.prevY = b.y;b.y -= 1;});
                this.bullets = this.bullets.filter(b => b.y >= -2);

                this.enemies.forEach(e => e.y += e.speed);
                this.enemies = this.enemies.filter(e => e.y < this.config.screenHeightChars +1); 
                
                this.asteroids.forEach(a => a.y += a.speed);
                this.asteroids = this.asteroids.filter(a => a.y < this.config.screenHeightChars + 1);
            },

            checkCollisions() {
                if(!this.isActive) return;

                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];

                        const crossesRow = bullet.prevY >= enemy.y && bullet.y <= enemy.y + 0.99;  

                        if (crossesRow && bullet.x >= enemy.x && bullet.x <  enemy.x + enemy.width) {
                            this.score += enemy.points;
                            this.callbacks.updateTotalScore(enemy.points); 
                            this.enemies.splice(j, 1);
                            this.bullets.splice(i, 1);
                            this.updateInfo();
                            break; 
                        }
                    }
                }

                const playerY = Math.floor(this.player.y);
                [...this.enemies, ...this.asteroids].forEach(obj => {
                    if(!this.isActive) return; // Check again in case a collision already ended the game
                    const objY = Math.floor(obj.y);
                    if (objY < playerY + 1 && objY +1 > playerY && 
                        this.player.drawX < obj.x + obj.width &&
                        this.player.drawX + this.player.width > obj.x) {
                        this.gameOver("Collision!");
                    }
                });
            },
            
            renderGameScreen() {
                if(!this.gameScreen) return; // Screen element might not be ready on very first call or after end
                for (let r = 0; r < this.config.screenHeightChars; r++) {
                    for (let c = 0; c < this.config.screenWidthChars; c++) {
                        this.charBuffer[r][c] = '&nbsp;';
                    }
                }

                for (let i = 0; i < this.player.width; i++) {
                    if (this.player.drawX + i < this.config.screenWidthChars && this.player.drawX + i >= 0) {
                         this.charBuffer[this.player.y][this.player.drawX + i] = this.player.char[i];
                    }
                }
                this.bullets.forEach(b => {
                    const y = Math.floor(b.y);
                    const x = Math.floor(b.x);
                    if (y >= 0 && y < this.config.screenHeightChars && x >=0 && x < this.config.screenWidthChars) this.charBuffer[y][x] = b.char;
                });
                this.enemies.forEach(e => {
                     const y = Math.floor(e.y);
                     if (y >=0 && y < this.config.screenHeightChars) {
                        for (let i = 0; i < e.width; i++) {
                           const x = Math.floor(e.x + i);
                           if (x < this.config.screenWidthChars && x >= 0) this.charBuffer[y][x] = `<span style="color:${e.colour}">${e.char[i]}</span>`;
                        }
                     }
                });
                this.asteroids.forEach(a => {
                    const y = Math.floor(a.y);
                    const x = Math.floor(a.x);
                     if (y >=0 && y < this.config.screenHeightChars && x >=0 && x < this.config.screenWidthChars) this.charBuffer[y][x] = `<span style="color:${a.colour}">${a.char}</span>`;
                });
                this.gameScreen.innerHTML = this.charBuffer.map(row => row.join('')).join('\n');
            },
            
            checkGameEnd() { 
                if (!this.isActive) return; 
                if (this.score >= this.targetScore) {
                    this.gameWon();
                } else {
                    this.gameOver(`Time up! Score ${this.score} < Target ${this.targetScore}`);
                }
            },

            gameWon() {
                 if (!this.isActive) return;
                 this.isActive = false; 
                 this.callbacks.addToLog("Astro Garden wave survived and target score met!");
                 this.callbacks.onWin(0); 
            },
            gameOver(reason) {
                if (!this.isActive) return;
                this.isActive = false; 
                this.callbacks.addToLog(`Astro Garden failed: ${reason}`);
                this.callbacks.onLoss(reason);
            }
        };

        /* ──────────────────────────────────────────────────────────────
        Root Circuit  v1.8 — always-solvable, never starts solved
        ---------------------------------------------------------------- */
        const RootCircuitGame = {
        name : "Root Circuit",

        /* injected by ArcadeManager */
        container:null, infoContainer:null, cycle:1, callbacks:null,

        /* runtime */
        grid:[], gridSize:0, timeLeft:0, timerId:null, solved:false,
        startCol:0, endCol:0,

        /* constants */
        config : {sizes:[6,7,9,11,13], times:[60,70,80,90,100]},
        DIRS   : [[-1,0],[0,1],[1,0],[0,-1]],                  // U,R,D,L
        SHAPES : [                                              // base rotations
            [1,0,1,0], [0,1,0,1], [1,1,0,0],
            [0,1,1,0], [0,0,1,1], [1,0,0,1]
        ],

        /* ───────────────── life-cycle ───────────────── */
        init(container,infoContainer,cycle,cb){
            Object.assign(this,{container,infoContainer,cycle,callbacks:cb});
            const idx=Math.min(cycle-1,this.config.sizes.length-1);
            this.gridSize=this.config.sizes[idx];
            this.timeLeft=this.config.times[idx];
            this.solved=false;
            this.buildGrid();
            this.render();
            this.updateInfo();
        },
        start(){
            this.callbacks.addToLog(
            "Root Circuit: rotate tiles to link  S  (green) to  E  (red)."
            );
            this.timerId=setInterval(()=>{
            this.timeLeft--; this.updateInfo();
            if(this.timeLeft<=0) this.gameOver("Signal surge – circuit overloaded!");
            },1000);
        },
        end(){
            clearInterval(this.timerId);
            this.callbacks?.addToLog("Root Circuit ended.");
        },

        /* ───────────────── UI ───────────────── */
        updateInfo(){
            this.infoContainer.innerHTML=
            `<div id="rootcircuit-info">⏱ ${this.timeLeft}s   Grid ${this.gridSize}×${this.gridSize}</div>`;
        },
        render(){
            this.container.innerHTML='<div id="rootcircuit-grid" class="grid-display"></div>';
            const g=document.getElementById('rootcircuit-grid');
            g.style.gridTemplateColumns=`repeat(${this.gridSize},24px)`;
            g.style.gridTemplateRows   =`repeat(${this.gridSize},24px)`;

            for(let r=0;r<this.gridSize;r++){
            for(let c=0;c<this.gridSize;c++){
                const t=this.grid[r][c], cell=document.createElement('div');
                cell.className='grid-cell';
                if(r===0 && c===this.startCol)         cell.classList.add('rc-start');
                if(r===this.gridSize-1 && c===this.endCol) cell.classList.add('rc-end');
                cell.innerHTML=this.svg(t.shapeIdx,t.rot);

                if(!(r===0&&c===this.startCol) && !(r===this.gridSize-1&&c===this.endCol)){
                cell.onclick=()=>{
                    if(this.solved) return;
                    t.rot=(t.rot+1)&3;
                    cell.innerHTML=this.svg(t.shapeIdx,t.rot);
                    this.trySolve();
                };
                }
                g.appendChild(cell);
            }
            }
        },
        svg(s,rot){
            const p=[
            `<rect x="10" y="3"  width="4" height="18" rx="2"/>`,
            `<rect x="3"  y="10" width="18" height="4" rx="2"/>`,
            `<rect x="10" y="3"  width="4" height="10" rx="2"/>
            <rect x="10" y="10" width="7" height="4" rx="2"/>`,
            `<rect x="10" y="10" width="7" height="4" rx="2"/>
            <rect x="10" y="10" width="4" height="10" rx="2"/>`,
            `<rect x="10" y="10" width="4" height="10" rx="2"/>
            <rect x="3"  y="10" width="7" height="4" rx="2"/>`,
            `<rect x="3"  y="10" width="7" height="4" rx="2"/>
            <rect x="10" y="3"  width="4" height="10" rx="2"/>`
            ];
            return `<svg width="24" height="24" viewBox="0 0 24 24">
                    <defs><filter id="g"><feGaussianBlur stdDeviation="1.4" result="c"/>
                    <feMerge><feMergeNode in="c"/><feMergeNode in="SourceGraphic"/>
                    </feMerge></filter>
                    <style><![CDATA[rect{fill:#00ff80;filter:url(#g);}]]></style></defs>
                    <g transform="rotate(${rot*90} 12 12)">${p[s]}</g></svg>`;
        },

        /* ───────────── grid generation ───────────── */
        buildGrid(){
            /* pick distinct columns */
            this.startCol=Math.floor(Math.random()*this.gridSize);
            do{this.endCol=Math.floor(Math.random()*this.gridSize);}
            while(this.endCol===this.startCol);

            /* random filler */
            this.grid=Array.from({length:this.gridSize},()=>(
            Array.from({length:this.gridSize},()=>({
                shapeIdx:Math.floor(Math.random()*this.SHAPES.length),
                rot:Math.floor(Math.random()*4)
            }))
            ));

            /* carve guaranteed path that drops into E from above */
            const path=this.makePath();                // list of [r,c]

            path.forEach(([r,c],i)=>{
            if(i===0||i===path.length-1){
                this.grid[r][c]={shapeIdx:0,rot:0};    // vertical for S & E
            }else{
                const [pr,pc]=path[i-1], [nr,nc]=path[i+1];
                const inDir =this.dirIdx(pr,pc,r,c);
                const outDir=this.dirIdx(r,c,nr,nc);
                this.grid[r][c]=this.tileFor(inDir,outDir);
            }
            });

            /* scramble everything once */
            for(let r=0;r<this.gridSize;r++)
            for(let c=0;c<this.gridSize;c++)
                if(!(r===0&&c===this.startCol)&&!(r===this.gridSize-1&&c===this.endCol))
                this.grid[r][c].rot=(this.grid[r][c].rot+Math.floor(Math.random()*4))&3;

            /* ensure UNSOLVED by rotating one interior path tile until it breaks */
            for(const [r,c] of this.shuffle(path.slice(1,-1))){
            const t=this.grid[r][c], originalRot=t.rot;
            for(let k=1;k<=3;k++){
                t.rot=(originalRot+k)&3;
                if(!this.isSolved()){return;}          // broken successfully
            }
            t.rot=originalRot;                       // restore & try another tile
            }
        },
        /* build path: wander until row-1, move horiz. to endCol, then step down */
        makePath(){
            const p=[[0,this.startCol]];
            let r=0,c=this.startCol;
            while(r<this.gridSize-2){                  // leave room for final drop
            const moves=[[1,0],[1,0]];               // bias down
            if(c>0)                 moves.push([0,-1]);
            if(c<this.gridSize-1)   moves.push([0,1]);
            const [dr,dc]=moves[Math.floor(Math.random()*moves.length)];
            r+=dr; c+=dc; p.push([r,c]);
            }
            while(c!==this.endCol){
            c+=(c<this.endCol)?1:-1; p.push([r,c]);
            }
            p.push([r+1,c]);                           // final drop into E
            return p;
        },
        tileFor(a,b){                                // 2-way tile opening a & b
            for(let s=0;s<this.SHAPES.length;s++)
            for(let rot=0;rot<4;rot++){
                const d=this.rot(this.SHAPES[s],rot);
                if(d[a]&&d[b]&&d.filter(Boolean).length===2)
                return {shapeIdx:s,rot};
            }
            return {shapeIdx:0,rot:0};                 // fallback (never hit)
        },

        /* helpers */
        shuffle(arr){for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];}return arr;},
        rot(bools,rot){const o=[0,0,0,0];for(let d=0;d<4;d++)o[(d+rot)&3]=bools[d];return o;},
        dirIdx(r1,c1,r2,c2){ if(r2<r1) return 0; if(c2>c1) return 1; if(r2>r1) return 2; return 3; },

        /* ───────────── solving logic ───────────── */
        dirs(t){return this.rot(this.SHAPES[t.shapeIdx],t.rot);},
        canEnter(r,c,from){ if(r<0||r>=this.gridSize||c<0||c>=this.gridSize) return false;
                            return this.dirs(this.grid[r][c])[(from+2)&3]; },
        dfs(r,c,v){
            if(r===this.gridSize-1&&c===this.endCol) return true;
            v[r][c]=true;
            const d=this.dirs(this.grid[r][c]);
            for(let i=0;i<4;i++)if(d[i]){
            const nr=r+this.DIRS[i][0], nc=c+this.DIRS[i][1];
            if(!this.canEnter(nr,nc,i)||v[nr]?.[nc]) continue;
            if(this.dfs(nr,nc,v)) return true;
            }
            return false;
        },
        isSolved(){
            if(!this.dirs(this.grid[0][this.startCol])[2]) return false;
            const v=Array.from({length:this.gridSize},()=>Array(this.gridSize).fill(false));
            return this.dfs(0,this.startCol,v);
        },
        trySolve(){
            if(this.solved) return;
            if(this.isSolved()){
            this.solved=true;
            const score=250+this.timeLeft*5;
            this.callbacks.addToLog(`Root Circuit complete! +${score}`);
            this.callbacks.onWin(score);
            }
        },

        /* ───────────── fail ───────────── */
        gameOver(reason){
            if(this.solved) return;
            this.callbacks.addToLog(`Root Circuit failed: ${reason}`);
            this.callbacks.onLoss(reason);
        }
        };



        // --- Initialize Arcade ---
        window.onload = () => {
            ArcadeManager.init();
        };
    </script>
</body>
</html>