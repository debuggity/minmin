<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MinMin [grdn_OS]</title>
    <style>
        :root {
            --primary-color: #00FF00;
            --bg-color: #000000;
            --border-color: #00FF00;
            --cell-bg: #003300;
            --cell-border: #004400;
            --cell-revealed-bg: #001500;
            --cell-revealed-border: #002500;
            --font-family: 'Consolas', 'Courier New', monospace;
        }

        body {
            background-color: var(--bg-color);
            color: var(--primary-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin: 0;
            padding: 20px;
            overflow-y: auto;
            min-height: 100vh;
            box-sizing: border-box;
        }

        #arcade-shell {
            border: 1px solid var(--border-color);
            padding: 15px;
            width: 95%;
            max-width: 1000px;
            box-shadow: 0 0 10px var(--border-color), 0 0 20px var(--border-color) inset;
        }

        h1, h2, h3 {
            color: var(--primary-color);
            text-shadow: 0 0 5px var(--primary-color);
            margin-top: 0;
        }

        #header { text-align: center; margin-bottom: 15px; }

        #global-info-panel {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px dashed var(--border-color);
        }
        #global-info-panel span { margin: 5px 10px; }

        #game-specific-area {
            min-height: 400px; /* Ensure space for games */
            border: 1px solid #005000;
            background-color: #001000;
            padding: 10px;
            margin-bottom: 15px;
            display: flex; /* For centering game content */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: none;
            background-size: cover;
            background-repeat: no-repeat;   /* no tiling                   */
            background-position: center;    /* always centred              */
            position: relative;              /* already set, but required */
            overflow: hidden;                /* clips overlay corners     */
        }

        /* Common Grid Cell Styling (can be overridden by specific games) */
        .grid-display {
            display: grid;
            gap: 1px;
            border: 1px solid #005000;
            background-color: #001000;
            user-select: none;
            touch-action: none; /* Prevent double tap zoom on mobile */
            margin: auto; /* Center grid if smaller than container */
        }

        .grid-cell {
            width: 20px;
            height: 20px;
            background-color: var(--cell-bg);
            border: 1px solid var(--cell-border);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
            color: var(--primary-color);
            position: relative; /* For decision point marker */
        }

        #log-area-container {
            margin-top: 15px;
            border: 1px dashed var(--border-color);
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            background-color: #001000;
        }
        #log-area-container pre { margin: 0; white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em; }

        button {
            background-color: #004400;
            color: var(--primary-color);
            border: 1px solid var(--border-color);
            padding: 8px 15px;
            cursor: pointer;
            font-family: inherit;
            text-shadow: 0 0 3px var(--primary-color);
            margin-top: 10px;
        }
        button:hover {
            background-color: #006600;
            box-shadow: 0 0 8px var(--primary-color);
        }
        button:disabled {
            background-color: #002200;
            color: #005500;
            border-color: #005500;
            cursor: not-allowed;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 20, 0, 0.95);
            display: flex; /* Initially hidden, shown by JS */
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 15px;
            box-sizing: border-box;
        }
        #overlay-content {
            background-color: #000000;
            border: 2px solid #00FF00;
            box-shadow:
                0 0 15px #00FF00,
                0 0 30px #00FF00 inset,
                0 0 3px  #00A0FF inset;   /* subtle blue inner-glow */
            padding: 24px 34px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            font-family: var(--font-family);
            color: var(--primary-color);
            text-shadow: 0 0 4px var(--primary-color);
        }

        #overlay-content h2 { font-size: 1.8em; margin-bottom: 15px; }
        #overlay-content p { margin-bottom: 15px; font-size: 1.1em; }
        #overlay-content pre { text-align: left; white-space: pre-wrap; max-height: 300px; overflow-y: auto;}
        
        #overlay.console-mode #overlay-content{
            background:#000;                           /* jet-black shell   */
            border:2px solid #00ff00;                  /* neon border       */
            box-shadow:0 0 15px #00ff00,
                    0 0 25px #00ff00 inset;         /* CRT glow          */
        }
        #overlay-console-text{                         /* scrolling text area */
            font-family:'Consolas','Courier New',monospace;
            color:#00ff00;
            text-shadow:0 0 3px #00ff00;
            white-space:pre-wrap;                      /* keep \n spacing   */
            line-height:1.35;
        }

        .blinking-cursor {
            animation: blink 1s step-end infinite;
        }
        @keyframes blink {
            50% { opacity: 0; }
        }

        /* Minesweeper Specific Styles */
        .sweeper-cell.revealed { background-color: var(--cell-revealed-bg); border-color: var(--cell-revealed-border); cursor: default; }
        .sweeper-cell.mine::before { content: "*"; color: #FF0000; font-weight: bold; }
        .sweeper-cell.flagged::before { content: "P"; color: #FFFF00; font-weight: bold; }
        .number-1 { color: #00FFFF; } .number-2 { color: #90EE90; } .number-3 { color: #FF4500; }
        .number-4 { color: #FFFF00; } .number-5 { color: #FF00FF; } .number-6 { color: #FFA500; }
        .number-7 { color: #DA70D6; } .number-8 { color: #D3D3D3; }

        /* Maze Runner Specific Styles */
        .maze-grid { /* Extends .grid-display */ }
        .maze-cell { /* Extends .grid-cell */ width: 18px; height: 18px; font-size: 12px; }
        .maze-cell.wall { background-color: #002200; }
        .maze-cell.path { background-color: #001000; }
        .maze-cell.player::before { content: "@"; color: #00FF00; font-weight: bold; z-index: 1; }
        .maze-cell.key::before { content: "$"; color: #FFFF00; font-weight: bold; z-index: 1;}
        .maze-cell.key-collected::before { content: "$"; color: #555500; z-index: 1;} /* Dim collected key */
        .maze-cell.finish::before { content: "F"; color: #00FFFF; font-weight: bold; z-index: 1;}
        .maze-cell.finish-locked::before { content: "F"; color: #005555; z-index: 1;} /* Dim locked finish */
        .maze-cell.decision-point-marker::after { /* Visual cue for decision points */
            content: '';
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #007700; /* A slightly darker green for subtlety */
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #maze-info { margin-bottom: 10px; font-size: 0.9em; }


        /* ASCII Galaga Specific Styles */
        #galaga-area {
            /* size the frame so 40 text columns fit perfectly */
            width: calc(40ch + 5px);      /* 40 = screenWidthChars; +2px = the 1-pixel border on each side */
            height: calc(35em * 0.75);    /* 20 rows * line-height ≈ 0.55em per row → matches char grid */
            margin: 0 auto;               /* centre inside #game-specific-area */
            
            display: flex;                /* centre the <pre> inside the frame */
            justify-content: center;
            align-items: center;

            background-color: #000500;
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color) inset;  /* optional CRT glow */
            
            font-family: var(--font-family);
            font-size: 16px;
            line-height: 1.1;
            color: var(--primary-color);
            overflow: hidden;
            box-sizing: border-box;
            user-select: none;
        }
        #galaga-area pre {
            white-space: pre;
            margin: 0;
            width: 100%;
            height: 100%;
            -webkit-user-select: none;   /* Safari/Chrome */
            -webkit-touch-callout: none; /* stops Google-Lens pop-up */
            user-select: none;           /* everyone else  */
        }
         #galaga-info { margin-bottom: 10px; font-size: 0.9em; }

         /* ==== PROGRESS-BAR WIDGETS ==== */
        #progress-bar-area{
            display:flex;
            gap:22px;
            align-items:flex-end;
            margin-top:6px;
        }
        .progress-wrapper{
            display:flex;
            flex-direction:column;
            align-items:center;
            user-select:none;
        }
        .progress-bar{
            width:24px;
            height:140px;
            border:1px solid var(--border-color);
            background:#002000;
            position:relative;
            overflow:hidden;
            box-shadow:0 0 6px #008000 inset;
        }

        /* common FILL base */
        .progress-bar .progress-fill{
            position:absolute;
            bottom:0;
            width:100%;
            height:0;           /* grows via JS */
            transition:height .4s ease-out;
        }

        /* ---- cycle: “black liquid & stars” ---- */
        .cycle-fill{
            background:#000;
        }
        .cycle-fill::before{
            content:"************************************************";
            position:absolute;
            width:100%;  height:220%;
            left:0; top:-100%;
            font-size:7px;
            line-height:7px;
            color:#ff0080;
            animation:starFloat 8s linear infinite;
            text-align:center;
        }
        @keyframes starFloat{
            0%{transform:translateY(0)}
            100%{transform:translateY(100%)}
        }

        /* ===== SCORE-DELTA BURST ===== */
        @keyframes pulseScore {
        0%   { transform: scale(0.5); opacity: 0; }
        35%  { transform: scale(1.6); opacity: 1; }
        60%  { transform: scale(1.0); }
        100% { opacity: 1; }
        }

        .score-delta {
        color: #00FF00;                /* neon green */
        display: inline-block;
        font-family: var(--font-family);
        font-size: 1.8em;
        font-weight: bold;
        letter-spacing: 1px;
        text-shadow: 0 0 6px #00FF00, 0 0 12px #00FF00;
        opacity: 0;                    /* shown via animation */
        }
        .score-delta.animate {
        animation: pulseScore 1.2s cubic-bezier(.14,1,.3,1) forwards;
        }

        /* ---- wave: Matrix stream ---- */
        .wave-fill{
            background:#001500;
        }
        .wave-fill::before{
            content:"010110001101001011001100101";
            position:absolute;
            width:100%; height:200%;
            left:0; top:-100%;
            font-size:9px;
            line-height:9px;
            color:#00ff00;
            opacity:.8;
            writing-mode:vertical-rl;
            text-orientation:upright;
            animation:matrixScroll 3s linear infinite;
        }
        @keyframes matrixScroll{
            to{transform:translateY(100%)}
        }

        .progress-fraction{
            margin-top:4px;
            font-size:.8em;
            color:var(--primary-color);
            text-shadow:0 0 2px var(--primary-color);
        }
        #fork-overlay {
            position: fixed;
            inset: 0;
            background: #000900 url('data:image/svg+xml,%3Csvg xmlns%3D%22http%3A//www.w3.org/2000/svg%22 width%3D%22100%25%22 height%3D%22100%25%22%3E%3Cdefs%3E%3ClinearGradient id%3D%22g%22 x1%3D%220%22 x2%3D%220%22 y1%3D%220%22 y2%3D%221%22%3E%3Cstop offset%3D%220%25%22 stop-color%3D%22%23002200%22/%3E%3Cstop offset%3D%22100%25%22 stop-color%3D%22%23000000%22/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width%3D%22100%25%22 height%3D%22100%25%22 fill%3D%22url(%23g)%22/%3E%3C/svg%3E') repeat;
            display: none;
            z-index: 1200;
            padding: 40px 25px;
            box-sizing: border-box;
            overflow: auto;
            text-align: center;
        }
        #fork-overlay h2{
            font-size:2em; margin-bottom:25px;
            color:#00FF80; text-shadow:0 0 6px #00FF80;
        }
        .path-gallery{
            display:flex; flex-wrap:wrap; gap:30px; justify-content:center;
        }
        .game-card{
            width:200px;          /* narrower */
            background:#001300;
            border:2px solid #007700;
            border-radius:10px;
            box-shadow:0 0 12px #009900 inset,0 0 6px #003300;
            padding:14px 14px 10px;
            cursor:pointer;
            display:flex;
            flex-direction:column;
            align-items:center;
            transition:transform .25s, box-shadow .25s;
        }
        .game-card:hover{
            transform:scale(1.05);
            box-shadow:0 0 14px #00FF00;
        }
        .game-card img{
            width:100%;
            aspect-ratio:4/3;     /* keeps them short */
            object-fit:cover;
            margin-bottom:6px;
            border:1px solid #004400;
        }
        .card-title{      font-size:1.1em; margin-bottom:4px; }
        .card-difficulty{ font-size:.85em; margin-bottom:6px;}
        .card-how{        font-size:.8em;  line-height:1.3;}

        /* ——— Root Circuit: Start/End styling ——— */
        .rc-start {
        background-color: #04A5FF !important;    /* bright green */
        cursor: default;                          /* non-rotatable */
        }
        .rc-end {
        background-color: #ff0000 !important;    /* bright red */
        cursor: default;
        }

        /* ================= MOBILE (≤600 px) ================= */
        @media (max-width:600px){
            body            { padding:10px; }
            #arcade-shell   { width:100%; max-width:none; padding:10px; }
            h1              { font-size:1.25em; margin-bottom:8px; }
            h2,h3           { font-size:1em;  }
            #global-info-panel{ flex-direction:column; font-size:.9em; }
            .progress-bar   { height:90px; width:20px; }
            #game-specific-area{ min-height:300px; }
            #overlay-content{ max-width:100%; font-size:.85em; padding:16px 18px; }
        }


    </style>
</head>
<body>
    <div id="arcade-shell">
        <div id="header">
            <h1>MinMin [grdn_OS]</h1>
        </div>

        <div id="global-info-panel">
            <span>Cycle: <span id="cycle-display">1</span></span>
            <span>Total Score: <span id="total-score-display">0</span></span>
            <span>Current Game: <span id="current-game-display">-</span></span>

            <!-- ▼ Progress Bars -->
            <div id="progress-bar-area">
                <!-- CYCLE BAR -->
                <div class="progress-wrapper">
                    <div id="cycle-bar"   class="progress-bar">
                        <div id="cycle-fill" class="cycle-fill"></div>
                    </div>
                    <span id="cycle-label" class="progress-fraction">0 / 5</span>
                </div>
            
                <!-- WAVE BAR -->
                <div class="progress-wrapper">
                    <div id="wave-bar"   class="progress-bar">
                        <div id="wave-fill"  class="wave-fill"></div>
                    </div>
                    <span id="wave-label"  class="progress-fraction">0 / 3</span>
                </div>
            </div>
            <!-- ▲ Progress Bars -->
  
        </div>

        <div id="game-specific-area">
            <!-- Game content will be loaded here by JavaScript -->
            <p>Initializing systems...</p>
        </div>
        
        <div id="game-specific-info-area" style="text-align: center; margin-bottom:10px;">
             <!-- Game specific status like timer, keys etc. -->
        </div>


        <div id="log-area-container">
            <pre id="log-display">> SYSTEM LOG INITIATED <<\n</pre>
        </div>

        <div id="overlay" style="display:none;"> <!-- Initially hidden -->
            <div id="overlay-content">
                <h2 id="overlay-title">SYSTEM BOOT</h2>
                <pre id="boot-sequence-display" style="text-align: left; white-space: pre-wrap;"></pre>
                <pre id="overlay-console-text"></pre>
                <div id="overlay-transition-info" style="white-space:pre-wrap; margin-bottom:15px;"></div>
                <div id="choice-gallery" class="path-gallery" style="display:none;"></div>
                <button id="overlay-action-btn">INITIATE SWEEP</button>
            </div>
        </div>
        
    </div>

    <script>

        /* ----------- mobile helpers ----------- */
        const isMobile = matchMedia('(pointer: coarse)').matches;     // true on phones/tablets
        const tapOpts  = { passive: true };                           // shorthand
        const tapBlock = { passive: false };

        const ArcadeManager = {
            currentCycle: 1,
            currentGameIndex: 0, // 0: Maze, 1: Sweeper, 2: Galaga
            totalScore: 0,

            GAMES_PER_CYCLE: 3,
            playsThisCycle: 0,
            MAX_CYCLES: 5,
            
            gameModules: [], // Will hold [MazeGame, SweeperGame, GalagaGame]

            availableGames: [],          // remaining choices this cycle
 
            dom: {
                overlayTransitionInfo: document.getElementById('overlay-transition-info'),
                cycleDisplay: document.getElementById('cycle-display'),
                totalScoreDisplay: document.getElementById('total-score-display'),
                currentGameDisplay: document.getElementById('current-game-display'),
                gameSpecificArea: document.getElementById('game-specific-area'),
                gameSpecificInfoArea: document.getElementById('game-specific-info-area'),
                logDisplay: document.getElementById('log-display'),
                overlay: document.getElementById('overlay'),
                overlayTitle: document.getElementById('overlay-title'),
                overlayConsoleText: document.getElementById('overlay-console-text'),  // ← new
                overlayActionBtn: document.getElementById('overlay-action-btn'),
                bootSequenceDisplay: document.getElementById('boot-sequence-display'),
                cycleFill  : document.getElementById('cycle-fill'),
                waveFill   : document.getElementById('wave-fill'),
                cycleLabel : document.getElementById('cycle-label'),
                waveLabel  : document.getElementById('wave-label'),
            },

            init() {
                this.log("ArcadeManager initializing...");
                this.gameModules = [MazeGame, SweeperGame, GalagaGame, RootCircuitGame]; // Order matters
                this.availableGames = [...this.gameModules];   // reset full list each new sequence
                this.dom.overlayActionBtn.onclick = () => this.startGameSequence();
                this.showBootScreen();
            },

            showBootScreen() {

                /* ─── reset overlay state ─── */
                this.dom.overlay.classList.remove('console-mode');
                this.dom.overlayTransitionInfo.style.display = 'none';
                this.dom.overlayTransitionInfo.textContent   = '';
                this.dom.overlayConsoleText.style.display    = 'block';

                this.dom.overlay.style.display = 'flex';
                this.dom.overlayTitle.textContent = "SYSTEM BOOT";
                this.dom.bootSequenceDisplay.style.display = 'block';

                //this.dom.overlayTransitionInfo.textContent = "";
                this.dom.overlayConsoleText.innerHTML = '';

                this.dom.overlayActionBtn.textContent = "INITIATE SEQUENCE";
                this.dom.overlayActionBtn.style.display = 'none'; // Shown after typing

                const bootMsg = `> BOOTING grdn_OS v3.1…
> Loading Game Modules:
>  - MAZE_RUNNER.MOD (v1.1)..... [LOADED]
>  - GRID_SWEEPER.MOD .......... [LOADED]
>  - ASTRO_GARDEN.MOD .......... [LOADED]
>  - ROOT_CIRCUIT.MOD .......... [LOADED]
> WELCOME, OPERATIVE.
> OBJECTIVE: Complete 5 cycles of increasing complexity.
> Each cycle in grdn_OS contains 3 forking paths.
>
> Press 'INITIATE SEQUENCE' to begin.`;
                
                // animate into the console-text area
                this.typeMessage(
                    this.dom.overlayConsoleText,
                    bootMsg,
                    () => { this.dom.overlayActionBtn.style.display = 'block' }
                );
            },

            typeMessage(element, message, callback, index = 0, speed = 15) {
                if (index < message.length) {
                    element.innerHTML += message[index] === '\n' ? '<br>' : message[index];
                    element.scrollTop = element.scrollHeight;
                    setTimeout(() => this.typeMessage(element, message, callback, index + 1, speed), speed);
                } else {
                    element.innerHTML = element.innerHTML.replace(/<span class="blinking-cursor">_<\/span>$/, ''); // Remove cursor
                    if (callback) callback();
                }
            },
            
            startGameSequence() {
                this.currentCycle = 1;
                this.playsThisCycle = 0;
                this.totalScore = 0;
                this.lastScoreDelta = 0;
                this.updateGlobalUI();
                this.log("New game sequence started.");

                // Ensure the overlay is in “console” style without previous boot text
                this.dom.overlay.classList.add('console-mode');
                this.dom.bootSequenceDisplay.style.display = 'none';
                this.dom.overlayConsoleText.style.display = 'block';
                this.dom.overlayConsoleText.innerHTML = ''; 
                this.dom.overlayTitle.textContent = "CHOOSE YOUR PATH";

                // Write a short prompt and then show two-game fork
                const prompt = "Select any of the two games below to begin.";
                this.typeMessage(
                this.dom.overlayConsoleText,
                prompt + "\n\n",
                () => this.showFork()
                );
            },

            loadNextGame() {
                this.dom.overlay.style.display = 'none';
                this.dom.gameSpecificArea.innerHTML = ""; // Clear previous game
                this.dom.gameSpecificInfoArea.innerHTML = ""; // Clear previous game info

                if (this.currentGameIndex >= this.gameModules.length) { // Cycle complete
                    this.currentCycle++;
                    this.currentGameIndex = 0;
                    if (this.currentCycle > this.MAX_CYCLES) {
                        this.overallWin();
                        return;
                    }
                    this.showTransitionScreen(true, this.lastScoreDelta); // True for start of new cycle
                } else {
                    this.showTransitionScreen(false, this.lastScoreDelta);
                }
            },

            startCurrentGame() {
                /* hide overlay and fetch the module first */
                this.dom.overlay.style.display = 'none';
                const gameModule = this.gameModules[this.currentGameIndex];

                /* --- background image for this game × cycle --- */
                const meta  = GameMeta[gameModule.name.replace(/\s+/g, '')];
                const bgURL = meta?.bg?.(this.currentCycle) || '';
                this.dom.gameSpecificArea.style.backgroundImage = bgURL ? `url("${bgURL}")` : 'none';

                /* normal start-up */
                this.dom.currentGameDisplay.textContent = gameModule.name;
                this.log(`Starting Game: ${gameModule.name}, Cycle: ${this.currentCycle}`);

                gameModule.init(
                    this.dom.gameSpecificArea,
                    this.dom.gameSpecificInfoArea,
                    this.currentCycle,
                    {
                        onWin:  (score) => this.handleGameWin(score),
                        onLoss: (why)  => this.handleGameLoss(why),
                        addToLog:        (msg) => this.log(`[${gameModule.name}] ${msg}`),
                        updateTotalScore:(pts) => { this.totalScore += pts; this.updateGlobalUI(); }
                    }
                );
                gameModule.start();
            },

            showTransitionScreen(isNewCycle, scoreDelta = 0, afterTypingCallback = null) {

                // 1) show overlay, hide boot log
                this.dom.overlay.style.display = 'flex';
                this.dom.bootSequenceDisplay.style.display = 'none';

                // 2) build title & message
                let title, message;
                if (isNewCycle) {
                    title   = `CYCLE ${this.currentCycle - 1} COMPLETE`;
                    message = `Total Score: ${this.totalScore}\n\n` +
                            `Starting Cycle ${this.currentCycle}/5.\n`;
                } else {
                    title   = `PREPARING NEXT CHALLENGE`;
                    message = `Total Score: ${this.totalScore}\n\n` +
                            `Cycle ${this.currentCycle}/5 continues.\n`;
                }

                // 3) colour‐code the heading
                if      (title.includes('COMPLETE')) this.dom.overlayTitle.style.color = '#00FF00';
                else if (title.includes('FAILED'))   this.dom.overlayTitle.style.color = '#FF0040';
                else                                 this.dom.overlayTitle.style.color = '#00A0FF';

                // 4) prepend score delta if any
                if (scoreDelta > 0) {
                    message = `+${scoreDelta}\n` + message;
                }

                // 5) set title
                this.dom.overlayTitle.textContent = title;

                // 6) switch into console mode & clear old text
                this.dom.overlay.classList.add('console-mode');
                this.dom.overlayConsoleText.innerHTML = '';
                this.dom.overlayActionBtn.style.display = 'none';

                // 7) prepare plain‐text typing string (no <span> tags)
                const typingString = message + '\n\nChoose your PATH to proceed.';

                // 8) type it out
                this.typeMessage(
                    this.dom.overlayConsoleText,
                    typingString,
                    () => {
                        // once done, append a real <span> blinking cursor
                        const cursor = document.createElement('span');
                        cursor.classList.add('blinking-cursor');
                        cursor.textContent = '_';
                        this.dom.overlayConsoleText.appendChild(cursor);

                        // show & wire up the button
                        this.dom.overlayActionBtn.style.display = 'block';
                        this.dom.overlayActionBtn.textContent = 'CONTINUE';
                        this.dom.overlayActionBtn.onclick = () => this.startCurrentGame();

                        if (afterTypingCallback) afterTypingCallback();
                    }
                );

                // reset for next time
                this.lastScoreDelta = 0;
            },

            showFork() {
                /* where to inject */
                const gallery = document.getElementById('choice-gallery');
                gallery.style.display = 'flex';
                gallery.innerHTML = '';

                /* ✧ get 2 random games ≠ last played */
                const lastPlayed = this.gameModules[this.currentGameIndex];
                const pool = this.gameModules.filter(g => g !== lastPlayed);
                pool.sort(() => Math.random() - 0.5);       // shuffle
                const choices = pool.slice(0, 2);

                /* build the cards */
                choices.forEach(mod => {
                    const meta = GameMeta[mod.name.replace(/\s+/g,'')];
                    const card = document.createElement('div');
                    card.className = 'game-card';
                    card.innerHTML = `
                        <img src="${meta.thumb}" alt="">
                        <div class="card-title">${mod.name}</div>
                        <div class="card-difficulty">${meta.difficultyName(this.currentCycle)}</div>
                        <div class="card-how">${meta.shortHow.replace(/\n/g,'<br>')}</div>`;
                    card.onclick = () => {
                        gallery.style.display = 'none';      // hide gallery
                        this.currentGameIndex = this.gameModules.indexOf(mod);
                        this.startCurrentGame();
                    };
                    gallery.appendChild(card);
                });

                /* hide the CONTINUE button & extra text */
                this.dom.overlayActionBtn.style.display = 'none';
                this.dom.overlayTransitionInfo.style.display = 'none';
            },

            updateGlobalUI() {
                this.dom.cycleDisplay.textContent  = this.currentCycle;
                this.dom.totalScoreDisplay.textContent = this.totalScore;

                this.updateProgressBars();          // ▼ new
            },

            updateProgressBars() {
                /* CYCLE bar – fills once a cycle is finished */
                const cyclePct = (this.currentCycle) / this.MAX_CYCLES * 100;
                this.dom.cycleFill.style.height = cyclePct + '%';
                this.dom.cycleLabel.textContent = `${this.currentCycle}/${this.MAX_CYCLES}`;

                /* WAVE bar – fills as games are cleared this cycle */
                const wavePct = this.playsThisCycle / this.GAMES_PER_CYCLE * 100;
                this.dom.waveFill.style.height  = wavePct + '%';
                this.dom.waveLabel.textContent  = `${this.playsThisCycle}/${this.GAMES_PER_CYCLE}`;
            },


            handleGameWin(scoreEarnedThisGame) {
                this.lastScoreDelta  = scoreEarnedThisGame;
                this.totalScore     += scoreEarnedThisGame;
                this.playsThisCycle += 1;
                this.updateGlobalUI();

                const played = this.gameModules[this.currentGameIndex];

                if (this.playsThisCycle >= this.GAMES_PER_CYCLE) {
                    // end of cycle
                    this.playsThisCycle = 0;
                    this.currentCycle++;

                    if (this.currentCycle > this.MAX_CYCLES) {
                        this.overallWin();
                        return;
                    }

                    this.showTransitionScreen(
                        true,
                        scoreEarnedThisGame,
                        () => this.showFork()
                    );
                } else {
                    // still within the same cycle
                    this.showTransitionScreen(
                        false,
                        scoreEarnedThisGame,    // ← now correctly passed
                        () => this.showFork()
                    );
                }

                if (played.end) {
                    played.end();
                }
            },

            handleGameLoss(reason) {
                this.log(`Game ${this.gameModules[this.currentGameIndex].name} LOST: ${reason}`);

                // Shut the current mini-game down cleanly
                if (this.gameModules[this.currentGameIndex].end) {
                    this.gameModules[this.currentGameIndex].end();
                }

                /* ---------- build failure summary ---------- */
                const summary = [
                    `Reason: ${reason}`,
                    `Total Score: ${this.totalScore}`,
                    `Reached Cycle: ${this.currentCycle}`,
                    `Failed Game: ${this.gameModules[this.currentGameIndex].name}`
                ].join('\n');

                /* ---------- show overlay ---------- */
                const d = this.dom;
                d.overlay.style.display = 'flex';
                d.overlay.classList.remove('console-mode');     // plain neon panel
                d.overlayTitle.textContent = 'SEQUENCE FAILED';

                d.bootSequenceDisplay.style.display   = 'none';
                d.overlayConsoleText.style.display    = 'none';
                d.overlayTransitionInfo.style.display = 'block';
                d.overlayTransitionInfo.textContent   = summary;

                /* ---------- restart button ---------- */
                d.overlayActionBtn.style.display = 'block';
                d.overlayActionBtn.textContent   = 'RESTART SEQUENCE';
                d.overlayActionBtn.onclick = () => this.init();

            },

            overallWin() {
                this.log("All cycles complete! VICTORY!");
                this.dom.overlay.style.display = 'flex';
                this.dom.overlayTitle.textContent = "SEQUENCE MASTERED!";
                this.dom.bootSequenceDisplay.style.display = 'none';
                this.dom.overlayTransitionInfo.innerHTML = `Congratulations, Operative! You have mastered all ${this.MAX_CYCLES} cycles!<br>Final Score: ${this.totalScore}`;
                this.dom.overlayActionBtn.textContent = "REPLAY";
                this.dom.overlayActionBtn.onclick = () => this.init();
            },

            log(message) {
                console.log(message);
                const time = new Date().toLocaleTimeString();
                this.dom.logDisplay.innerHTML += `[${time}] ${message}\n`;
                this.dom.logDisplay.scrollTop = this.dom.logDisplay.scrollHeight;
            }
        };

        /* ---------- GAME REGISTRY ---------- */
        const GameMeta = {
            MazeRunner : {
                thumb : 'assets/maze.png',
                shortHow: 'Slide with ↑↓←→ until you hit a wall or junction.\nGrab all keys, then reach the F.',
                difficultyName(cycle){ return ['Sprout','Sapling','Stalk','Bloom','Elder'][cycle-1]; },
                bg: c => `assets/bg/maze_${c}.png`
            },
            GridSweeper: {
                thumb : 'assets/sweeper.png',
                shortHow: 'Reveal safe tiles, flag mines (right-click).\nFirst click is always safe.',
                difficultyName(cycle){ return ['Pebble','Stone','Boulder','Cliff','Mountain'][cycle-1]; },
                bg: c => `assets/bg/sweeper_${c}.png`
            },
            AstroGarden: {
                thumb : 'assets/astra.png',
                shortHow: '←/→ to move, Space to shoot.\nHit score before timer ends.',
                difficultyName(cycle){ return ['Orbit I','Orbit II','Orbit III','Nebula','Supernova'][cycle-1]; },
                bg: c => `assets/bg/galaga_${c}.png`
            },
            RootCircuit: {
                thumb: 'assets/root.png',
                shortHow: 'Rotate tiles to connect a path from top to bottom.\nComplete before the circuit pulses!',
                difficultyName(cycle) { return ['Boot', 'Flow', 'Pulse', 'Surge', 'Overload'][cycle-1]; },
                bg: c => `assets/bg/root_${c}.png`
            },
            /* ✧ add future modules here the same way */
        };


        // --- Maze Runner Game Module (v1.1 - Decision Points Update) ---
        const MazeGame = {
            name: "Maze Runner",
            container: null,
            infoContainer: null,
            cycle: 1,
            callbacks: null,
            maze: [], // Will be array of cell objects: {isWall, isKey, isFinish, isDecisionPoint, keyCollected}
            player: { r: 0, c: 0 },
            keysToCollect: 0,
            keysCollected: 0,
            finish: { r: 0, c: 0, locked: true },
            timerId: null,
            _touchStartHandler: null,
            _touchEndHandler : null,
            _touchMoveHandler: null,
            timeLeft: 0,
            config: {
                cellSize: 18, 
                sizes: [ {w:7, h:7}, {w:9, h:9}, {w:11, h:11}, {w:13, h:13}, {w:15, h:15} ], 
                numKeys: [2, 3, 4, 5, 6],
                times: [25, 30, 35, 40, 45] // Increased times slightly
            },
            gridElement: null,

            init(container, infoContainer, cycle, callbacks) {
                this.container = container;
                this.infoContainer = infoContainer;
                this.cycle = cycle;
                this.callbacks = callbacks;
                
                const cycleConfigIndex = Math.min(cycle - 1, this.config.sizes.length - 1);
                this.mazeWidth = this.config.sizes[cycleConfigIndex].w * 2 + 1;
                this.mazeHeight = this.config.sizes[cycleConfigIndex].h * 2 + 1;
                this.keysToCollect = this.config.numKeys[cycleConfigIndex];
                this.timeLeft = this.config.times[cycleConfigIndex];
                this.keysCollected = 0;
                this.finish.locked = true;

                this.container.innerHTML = `<div id="maze-runner-grid" class="grid-display maze-grid"></div>`;
                this.gridElement = document.getElementById('maze-runner-grid');
                this.updateInfo();
                this.generateMaze();
            },

            start() {
                this.callbacks.addToLog("Maze Runner started. Swipe or use ↑ ↓ ← → to move.");
                document.addEventListener("keydown", this.handleKey);

                /* ─── mobile swipe → virtual arrow-key ─── */
                if (isMobile) {
                    const Z = this.container;
                    let sx = 0, sy = 0;                                 // swipe origin

                    this._touchStartHandler = e => {
                        e.preventDefault();
                        const t = e.touches[0];
                        sx = t.clientX;
                        sy = t.clientY;
                    };

                    this._touchEndHandler = e => {
                        e.preventDefault();
                        const t = e.changedTouches[0];
                        const dx = t.clientX - sx;
                        const dy = t.clientY - sy;
                        if (Math.abs(dx) < 30 && Math.abs(dy) < 30) return;   // ignore taps

                        const key = Math.abs(dx) > Math.abs(dy)
                            ? (dx > 0 ? "ArrowRight" : "ArrowLeft")
                            : (dy > 0 ? "ArrowDown"  : "ArrowUp");

                        MazeGame.handleKey(new KeyboardEvent("keydown", { key }));
                    };

                    this._touchMoveHandler = e => e.preventDefault();   // cancel scroll / pinch

                    Z.addEventListener("touchstart", this._touchStartHandler, { passive: false });
                    Z.addEventListener("touchend",   this._touchEndHandler,   { passive: false });
                    Z.addEventListener("touchmove",  this._touchMoveHandler,  { passive: false });
                }

                this.timerId = setInterval(() => {
                    if (--this.timeLeft <= 0) this.gameOver("Time ran out!");
                    this.updateInfo();
                }, 1000);

                this.renderMaze();
            },


            end() {
                clearInterval(this.timerId);
                this.timerId = null;

                document.removeEventListener("keydown", this.handleKey);

                /* detach any swipe listeners we attached earlier */
                if (isMobile && this._touchStartHandler) {
                    const Z = this.container;
                    Z.removeEventListener("touchstart", this._touchStartHandler, { passive: false });
                    Z.removeEventListener("touchend",   this._touchEndHandler,   { passive: false });
                    Z.removeEventListener("touchmove",  this._touchMoveHandler,  { passive: false });
                    this._touchStartHandler =
                    this._touchEndHandler  =
                    this._touchMoveHandler = null;
                }

                this.callbacks?.addToLog(`${this.name} ended.`);
                this.callbacks = null;
            },

            updateInfo() {
                this.infoContainer.innerHTML = `<div id="maze-info">Time: ${this.timeLeft}s | Keys: ${this.keysCollected}/${this.keysToCollect}</div>`;
            },

            generateMaze() {
                let numberMaze = Array(this.mazeHeight).fill(null).map(() => Array(this.mazeWidth).fill(1)); // 1 for wall

                function carve(r, c, mazeToCarve, height, width) {
                    mazeToCarve[r][c] = 0; // 0 for path
                    const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                    directions.sort(() => Math.random() - 0.5); 

                    for (let [dr, dc] of directions) {
                        const nr = r + dr, nc = c + dc;
                        const wallR = r + dr / 2, wallC = c + dc / 2;
                        if (nr > 0 && nr < height - 1 && nc > 0 && nc < width - 1 && mazeToCarve[nr][nc] === 1) {
                            mazeToCarve[wallR][wallC] = 0;
                            carve(nr, nc, mazeToCarve, height, width);
                        }
                    }
                }
                carve(1, 1, numberMaze, this.mazeHeight, this.mazeWidth);

                // Convert number maze to object maze and identify decision points
                this.maze = Array(this.mazeHeight).fill(null).map(() => Array(this.mazeWidth).fill(null));
                for (let r = 0; r < this.mazeHeight; r++) {
                    for (let c = 0; c < this.mazeWidth; c++) {
                        const isWallCell = numberMaze[r][c] === 1;
                        this.maze[r][c] = {
                            isWall: isWallCell,
                            isKey: false,
                            isFinish: false,
                            isDecisionPoint: false,
                            keyCollected: false
                        };

                        if (!isWallCell) { // If it's a path, check if it's a decision point
                            let pathNeighbors = 0;
                            const DIRS = [[-1,0], [1,0], [0,-1], [0,1]];
                            for (const [dr, dc] of DIRS) {
                                const nr_check = r + dr;
                                const nc_check = c + dc;
                                if (nr_check >= 0 && nr_check < this.mazeHeight && nc_check >= 0 && nc_check < this.mazeWidth && numberMaze[nr_check][nc_check] === 0) {
                                    pathNeighbors++;
                                }
                            }
                            if (pathNeighbors >= 3) { // T-junction or crossroad
                                this.maze[r][c].isDecisionPoint = true;
                            }
                        }
                    }
                }
                
                this.player = { r: 1, c: 1 };
                if (this.maze[1][1].isWall) { 
                    this.callbacks.addToLog("Error: Player start is wall. Fixing.");
                    this.maze[1][1].isWall = false;
                    // Ensure it's not a decision point if it was fixed to path
                    if (this.maze[1][1].isDecisionPoint) this.maze[1][1].isDecisionPoint = false; 
                }

                // Place keys
                for (let i = 0; i < this.keysToCollect; i++) {
                    let kr, kc;
                    let attempts = 0;
                    do {
                        kr = Math.floor(Math.random() * (this.mazeHeight - 2)) + 1; // Ensure within pathable area
                        kc = Math.floor(Math.random() * (this.mazeWidth - 2)) + 1;
                        attempts++;
                        if (attempts > this.mazeHeight * this.mazeWidth * 2) { 
                            this.callbacks.addToLog("Warning: Could not place all keys despite attempts."); break;
                        }
                    } while (this.maze[kr][kc].isWall || this.maze[kr][kc].isKey || this.maze[kr][kc].isFinish || (kr === this.player.r && kc === this.player.c));
                    if (!this.maze[kr][kc].isWall) this.maze[kr][kc].isKey = true; else if(attempts <= this.mazeHeight * this.mazeWidth *2) i--; // Try placing this key again
                }
                
                // Place finish
                let finish_attempts = 0;
                do {
                    this.finish.r = Math.floor(Math.random() * (this.mazeHeight - 2)) + 1;
                    this.finish.c = Math.floor(Math.random() * (this.mazeWidth - 2)) + 1;
                    finish_attempts++;
                    if (finish_attempts > this.mazeHeight * this.mazeWidth * 2) { 
                        this.callbacks.addToLog("Warning: Could not place finish despite attempts."); break;
                    }
                } while (this.maze[this.finish.r][this.finish.c].isWall || this.maze[this.finish.r][this.finish.c].isKey || this.maze[this.finish.r][this.finish.c].isFinish || (this.finish.r === this.player.r && this.finish.c === this.player.c));
                if(!this.maze[this.finish.r][this.finish.c].isWall) this.maze[this.finish.r][this.finish.c].isFinish = true;
            },

            renderMaze() {
                this.gridElement.innerHTML = '';
                this.gridElement.style.gridTemplateColumns = `repeat(${this.mazeWidth}, ${this.config.cellSize}px)`;
                this.gridElement.style.gridTemplateRows = `repeat(${this.mazeHeight}, ${this.config.cellSize}px)`;

                for (let r = 0; r < this.mazeHeight; r++) {
                    for (let c = 0; c < this.mazeWidth; c++) {
                        const cellDiv = document.createElement('div');
                        cellDiv.classList.add('grid-cell', 'maze-cell');
                        const cellData = this.maze[r][c];

                        if (cellData.isWall) cellDiv.classList.add('wall');
                        else cellDiv.classList.add('path');

                        if (r === this.player.r && c === this.player.c) cellDiv.classList.add('player');
                        
                        if (cellData.isKey) {
                            cellDiv.classList.add('key');
                            if (cellData.keyCollected) cellDiv.classList.add('key-collected');
                        }

                        if (cellData.isFinish) {
                            cellDiv.classList.add('finish');
                            if (this.finish.locked) cellDiv.classList.add('finish-locked');
                        }
                        if (cellData.isDecisionPoint && !cellData.isWall && !(r === this.player.r && c === this.player.c) && !cellData.isKey && !cellData.isFinish) {
                            cellDiv.classList.add('decision-point-marker');
                        }
                        this.gridElement.appendChild(cellDiv);
                    }
                }
            },

            /* ── helper: are we on a run-time decision point? ─────────────────── */
            runtimeDecision(r, c) {
                const dirs = [[-1,0],[1,0],[0,-1],[0,1]];      // U, D, L, R
                let paths = 0, vertical = 0, horizontal = 0;
                for (const [dr, dc] of dirs) {
                    const nr = r + dr, nc = c + dc;
                    if (nr < 0 || nr >= this.mazeHeight || nc < 0 || nc >= this.mazeWidth)
                        continue;
                    if (!this.maze[nr][nc].isWall) {
                        paths++;
                        if (dr) vertical   = 1;
                        else    horizontal = 1;
                    }
                }
                return (paths >= 3) || (vertical && horizontal);
            },

            /* ── FULL replacement for MazeGame.handleKey ─────────────────────── */
            handleKey: (e) => {
                if (e.preventDefault) e.preventDefault();
                if (!MazeGame.timerId || MazeGame.timeLeft <= 0) return;

                let dr = 0, dc = 0;
                switch (e.key) {
                    case 'ArrowUp':    dr = -1; break;
                    case 'ArrowDown':  dr =  1; break;
                    case 'ArrowLeft':  dc = -1; break;
                    case 'ArrowRight': dc =  1; break;
                    default: return;
                }

                const { r: startR, c: startC } = MazeGame.player;
                let r = startR, c = startC;

                /* slide until wall **or a pre-tagged decision point** */
                while (true) {
                    const nr = r + dr, nc = c + dc;

                    if (nr < 0 || nr >= MazeGame.mazeHeight ||
                        nc < 0 || nc >= MazeGame.mazeWidth ||
                        MazeGame.maze[nr][nc].isWall) break;

                    r = nr; c = nc;
                    const cell = MazeGame.maze[r][c];

                    if (cell.isKey && !cell.keyCollected) {
                        cell.keyCollected = true;
                        MazeGame.keysCollected++;
                        MazeGame.callbacks.addToLog(
                            `Collected key (${MazeGame.keysCollected}/${MazeGame.keysToCollect})`
                        );
                        if (MazeGame.keysCollected === MazeGame.keysToCollect) {
                            MazeGame.finish.locked = false;
                            MazeGame.callbacks.addToLog("All keys collected! Finish unlocked.");
                        }
                        MazeGame.updateInfo();
                    }

                    if (cell.isFinish && !MazeGame.finish.locked) {
                        MazeGame.player = { r, c };
                        MazeGame.gameWon();
                        return;
                    }

                    /* stop on any 3-way or 4-way junction (tagged earlier) */
                    if ((r !== startR || c !== startC) && cell.isDecisionPoint) break;
                }

                MazeGame.player = { r, c };
                if (r === MazeGame.finish.r && c === MazeGame.finish.c && !MazeGame.finish.locked)
                    MazeGame.gameWon();
                else
                    MazeGame.renderMaze();
            },

            gameWon() {
                if (!this.timerId) return; // Already ended
                this.callbacks.addToLog("Maze cleared!");
                const score = this.timeLeft * 25; // Keys score added globally by ArcadeManager
                this.callbacks.onWin(score); 
            },

            gameOver(reason) {
                if (!this.timerId) return; // Already ended
                this.callbacks.addToLog(`Maze failed: ${reason}`);
                this.callbacks.onLoss(reason);
            }
        };

        // --- Grid Sweeper Game Module (Refactored) ---
        const SweeperGame = {
            name: "Grid Sweeper",
            container: null,
            infoContainer: null,
            cycle: 1,
            callbacks: null,
            gs: {}, // Game State for sweeper
            config: {
                cellSize: 20,
                gridSizes: [6, 8, 12, 16, 22], // Size (N x N)
                minePercentage: 0.12
            },
            gridElement: null,

            init(container, infoContainer, cycle, callbacks) {
                /* ▼ basic wiring -------------------------------------------------- */
                this.container       = container;
                this.infoContainer   = infoContainer;
                this.cycle           = cycle;
                this.callbacks       = callbacks;

                /* ▼ cycle-scaled params ------------------------------------------- */
                const idx          = Math.min(cycle - 1, this.config.gridSizes.length - 1);
                const gridSize     = this.config.gridSizes[idx];

                this.gs = {
                    grid: [],
                    rows: gridSize,
                    cols: gridSize,
                    numMines: Math.floor(gridSize * gridSize * this.config.minePercentage),
                    flagsPlaced: 0,
                    cellsRevealed: 0,
                    totalNonMineCells: 0,
                    gameOver: false,
                    firstClick: true,
                    firstClickCell: { r: -1, c: -1 }
                };

                /* ▼ shell --------------------------------------------------------- */
                this.container.innerHTML =
                    `<div id="sweeper-grid" class="grid-display"></div>`;
                this.gridElement     = document.getElementById('sweeper-grid');

                /* ▼ info panel stub + (mobile) toggle ----------------------------- */
                this.infoContainer.innerHTML =
                    `<div id="sweeper-info"></div>`;              // text only – toggle sits next to it

                this.flagMode = false;                           // ← new flag mode
                if (isMobile) {
                    const toggle = document.createElement('label');
                    toggle.style.fontSize = '.85em';
                    toggle.innerHTML =
                        `<input type="checkbox" id="flag-toggle"> Flag Mode`;
                    this.infoContainer.appendChild(toggle);
                    toggle.querySelector('#flag-toggle')
                        .addEventListener('change', e => {
                            this.flagMode = e.target.checked;
                        }, tapOpts);
                }

                /* ▼ pre-compute & paint grid shell -------------------------------- */
                this.gs.totalNonMineCells =
                    (this.gs.rows * this.gs.cols) - this.gs.numMines;
                this.updateInfo();
                this.renderInitialGridShell();
            },
            
            renderInitialGridShell() { 
                this.gridElement.innerHTML = '';
                this.gridElement.style.gridTemplateColumns = `repeat(${this.gs.cols}, ${this.config.cellSize}px)`;
                this.gridElement.style.gridTemplateRows = `repeat(${this.gs.rows}, ${this.config.cellSize}px)`;

                for (let r = 0; r < this.gs.rows; r++) {
                    this.gs.grid[r] = [];
                    for (let c = 0; c < this.gs.cols; c++) {
                        this.gs.grid[r][c] = { 
                            isMine: false, isRevealed: false, isFlagged: false, adjacentMines: 0
                        };
                        const div = document.createElement('div');
                        div.classList.add('grid-cell', 'sweeper-cell');
                        div.dataset.r = r;
                        div.dataset.c = c;
                        div.addEventListener('click', () => this.handleLeftClick(r, c));
                        div.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            this.handleRightClick(r, c);
                        });
                        this.gridElement.appendChild(div);
                    }
                }
            },

            start() {
                this.callbacks.addToLog("Grid Sweeper started. Click to reveal, Right-click to flag.");
            },
            
            end() {
                 this.callbacks.addToLog("Grid Sweeper ended.");
            },

            // replace SweeperGame.updateInfo() with:
            updateInfo(){
                const lbl = document.getElementById('sweeper-info');
                if (!lbl) return;
                lbl.textContent =
                `Mines: ${this.gs.numMines} | Flags: ${this.gs.flagsPlaced} | `
                + `Revealed: ${this.gs.cellsRevealed}/${this.gs.totalNonMineCells}`;
            },

            setupGridAndMines() { 
                const { r: firstR, c: firstC } = this.gs.firstClickCell;
                
                for (let r_init = 0; r_init < this.gs.rows; r_init++) {
                    for (let c_init = 0; c_init < this.gs.cols; c_init++) {
                        this.gs.grid[r_init][c_init].isMine = false;
                        this.gs.grid[r_init][c_init].adjacentMines = 0;
                    }
                }

                let minesToPlace = this.gs.numMines;
                const safeZone = [];
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                         const nr = firstR + dr;
                         const nc = firstC + dc;
                         if (nr >=0 && nr < this.gs.rows && nc >=0 && nc < this.gs.cols) {
                            safeZone.push(`${nr},${nc}`);
                         }
                    }
                }
                
                let attempts = 0;
                let actualMinesPlaced = 0;
                while (minesToPlace > 0 && attempts < this.gs.rows * this.gs.cols * 2) { 
                    const r = Math.floor(Math.random() * this.gs.rows);
                    const c = Math.floor(Math.random() * this.gs.cols);
                    if (!this.gs.grid[r][c].isMine && !safeZone.includes(`${r},${c}`)) {
                        this.gs.grid[r][c].isMine = true;
                        minesToPlace--;
                        actualMinesPlaced++;
                    }
                    attempts++;
                }
                 if (minesToPlace > 0) this.callbacks.addToLog(`Warning: Could not place all ${this.gs.numMines} mines. Placed ${actualMinesPlaced}.`);
                 this.gs.numMines = actualMinesPlaced; // Update to actual mines on grid.


                for (let r_adj = 0; r_adj < this.gs.rows; r_adj++) {
                    for (let c_adj = 0; c_adj < this.gs.cols; c_adj++) {
                        if (this.gs.grid[r_adj][c_adj].isMine) continue;
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = r_adj + dr;
                                const nc = c_adj + dc;
                                if (nr >= 0 && nr < this.gs.rows && nc >= 0 && nc < this.gs.cols && this.gs.grid[nr][nc].isMine) {
                                    count++;
                                }
                            }
                        }
                        this.gs.grid[r_adj][c_adj].adjacentMines = count;
                    }
                }
                this.gs.totalNonMineCells = (this.gs.rows * this.gs.cols) - this.gs.numMines; 
                this.updateInfo(); 
            },

            renderGrid() { 
                this.gridElement.innerHTML = ''; 
                this.gridElement.style.gridTemplateColumns = `repeat(${this.gs.cols}, ${this.config.cellSize}px)`;
                this.gridElement.style.gridTemplateRows = `repeat(${this.gs.rows}, ${this.config.cellSize}px)`;

                for (let r = 0; r < this.gs.rows; r++) {
                    for (let c = 0; c < this.gs.cols; c++) {
                        const cell = this.gs.grid[r][c];
                        const div = document.createElement('div');
                        div.classList.add('grid-cell', 'sweeper-cell');
                        div.dataset.r = r;
                        div.dataset.c = c;

                        if (cell.isRevealed) {
                            div.classList.add('revealed');
                            if (cell.isMine) {
                                div.classList.add('mine');
                            } else if (cell.adjacentMines > 0) {
                                div.textContent = cell.adjacentMines;
                                div.classList.add(`number-${Math.min(cell.adjacentMines, 8)}`);
                            }
                        } else { 
                            if (cell.isFlagged) {
                                div.classList.add('flagged');
                            }
                        }
                        if (!this.gs.gameOver) {
                            div.addEventListener('click', () => this.handleLeftClick(r, c));
                            div.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                this.handleRightClick(r, c);
                            });
                        }
                        this.gridElement.appendChild(div);
                    }
                }
            },

            handleLeftClick(r, c) {
                if (this.gs.gameOver) return;

                /* ─── Mobile: when “Flag Mode” switch is on, a tap works like a right-click ─── */
                // ┌───────────────────────────────────────────────────────────────────────────┐
                if (isMobile && this.flagMode) {
                    this.handleRightClick(r, c);   // place / remove flag
                    return;                         // skip reveal logic
                }
                // └───────────────────────────────────────────────────────────────────────────┘

                /* ─── Desktop (or mobile in Reveal mode) ─── */
                if (this.gs.firstClick) {
                    this.gs.firstClick = false;
                    this.gs.firstClickCell = { r, c };
                    this.setupGridAndMines();          // build mines away from safe zone
                    this.revealCell(r, c, true);       // good-start flood fill
                    this.renderGrid();
                    return;
                }

                const cell = this.gs.grid[r][c];
                if (cell.isRevealed || cell.isFlagged) return;

                this.revealCell(r, c, false);
                if (!this.gs.gameOver) this.renderGrid();   // skip if reveal ended game
            },
            
            revealCell(r, c, isFirstClickContext = false) { 
                const cell = this.gs.grid[r][c];
                // If already revealed or flagged, or game is over, do nothing
                if (cell.isRevealed || cell.isFlagged || this.gs.gameOver) return;
            
                cell.isRevealed = true;
            
                if (cell.isMine) {
                    this.gameOver("Hit a mine!"); // This will call renderGrid after setting mines
                    return;
                }
            
                this.gs.cellsRevealed++;
                this.callbacks.updateTotalScore(10); 
            
                // Flood fill logic
                if (cell.adjacentMines === 0) {
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            // For regular flood fill, (dr === 0 && dc === 0) means current cell, skip.
                            if (dr === 0 && dc === 0) continue; 
                            const nr = r + dr;
                            const nc = c + dc;
                            if (nr >= 0 && nr < this.gs.rows && nc >= 0 && nc < this.gs.cols) {
                                this.revealCell(nr, nc, false); // Not firstClickContext for recursive calls
                            }
                        }
                    }
                } 
                // If it's the first click context, and the initially clicked cell was a 0,
                // also reveal its direct non-mine neighbors even if they have numbers.
                // This is implicitly handled by the above if adjacentMines === 0, which is guaranteed for first click cell.
                // The guarantee is that the first clicked cell will be a 0, so its neighbors will be revealed by the normal flood fill.
                // If it was NOT a 0, it would be revealed, and its neighbors (if numbers) would not auto-reveal.
                // The core idea of "good start" is the 3x3 safe zone, making the clicked cell a 0.
            
                this.updateInfo();
                this.checkWinCondition(); // This might call gameWon(), which could render.
            },

            handleRightClick(r, c) {
                if (this.gs.gameOver || this.gs.firstClick) return; 
                const cell = this.gs.grid[r][c];
                if (cell.isRevealed) return;

                cell.isFlagged = !cell.isFlagged;
                if (cell.isFlagged) {
                    this.gs.flagsPlaced++;
                    if (cell.isMine) this.callbacks.updateTotalScore(20); 
                    else this.callbacks.updateTotalScore(-10); 
                } else {
                    this.gs.flagsPlaced--;
                }
                this.updateInfo();
                this.renderGrid(); 
            },

            revealAllMines() {
                for (let r_reveal = 0; r_reveal < this.gs.rows; r_reveal++) {
                    for (let c_reveal = 0; c_reveal < this.gs.cols; c_reveal++) {
                        if (this.gs.grid[r_reveal][c_reveal].isMine) {
                            this.gs.grid[r_reveal][c_reveal].isRevealed = true;
                        }
                    }
                }
            },

            checkWinCondition() {
                if (!this.gs.gameOver && this.gs.cellsRevealed === this.gs.totalNonMineCells && this.gs.totalNonMineCells > 0) {
                    this.gameWon();
                }
            },

            gameWon() {
                if(this.gs.gameOver) return; // Prevent multiple calls
                this.gs.gameOver = true; 
                this.callbacks.addToLog("Grid Sweeper map cleared!");
                this.callbacks.updateTotalScore(this.gs.numMines * 30); 
                this.renderGrid(); 
                this.callbacks.onWin(0); 
            },

            gameOver(reason) {
                if(this.gs.gameOver) return; // Prevent multiple calls
                this.gs.gameOver = true; 
                this.callbacks.addToLog(`Grid Sweeper failed: ${reason}`);
                this.revealAllMines();
                this.renderGrid(); 
                this.callbacks.onLoss(reason);
            }
        };

        // --- ASCII Galaga Game Module ---
        const GalagaGame = {
            name: "Astro Garden",
            container: null,
            infoContainer: null,
            cycle: 1,
            callbacks: null,
            config: {
                survivalTime: 35, 
                targetScores: [800, 1000, 1100, 1400, 1600],
                enemyBaseSpeed: [0.05, 0.07, 0.075, 0.08, 0.085], 
                enemySpawnInterval: [1500, 1200, 1000, 900, 800], 
                asteroidSpawnInterval: [2000, 1700, 1400, 1200, 1100],
                screenWidthChars: 40,
                screenHeightChars: 20,
            },
            player: { x: 0, y: 0, char: '^A^', width: 3, vx: 0 },
            keysPressed: {},
            playerSpeed: 0.40,
            bullets: [],
            enemies: [], 
            asteroids: [], 
            score: 0,
            timeLeft: 0,
            targetScore: 0,
            gameLoopId: null,
            spawnTimers: {},
            gameScreen: null, 
            charBuffer: [], 
            isActive: false, 

            init(container, infoContainer, cycle, callbacks) {
                this.container = container;
                this.infoContainer = infoContainer;
                this.cycle = cycle;
                this.callbacks = callbacks;
                this.isActive = false; 

                this.keysPressed     = { left: false, right: false };

                const cIdx = Math.min(cycle - 1, this.config.targetScores.length - 1);
                this.timeLeft = this.config.survivalTime;
                this.targetScore = this.config.targetScores[cIdx];
                this.currentEnemySpeed = this.config.enemyBaseSpeed[cIdx];
                this.currentEnemySpawnInterval = this.config.enemySpawnInterval[cIdx];
                this.currentAsteroidSpawnInterval = this.config.asteroidSpawnInterval[cIdx];
                
                this.score = 0;
                this.bullets = [];
                this.enemies = [];
                this.asteroids = [];
                
                this.player.x = Math.floor(this.config.screenWidthChars / 2) - Math.floor(this.player.width / 2);
                this.player.y = this.config.screenHeightChars - 1;

                this.container.innerHTML = `<div id="galaga-area"><pre id="galaga-screen"></pre></div>`;
                this.gameScreen = document.getElementById('galaga-screen');
                this.updateInfo();
                this.initCharBuffer();
                this.renderGameScreen(); 
            },

            initCharBuffer() {
                this.charBuffer = [];
                for (let i = 0; i < this.config.screenHeightChars; i++) {
                    this.charBuffer[i] = Array(this.config.screenWidthChars).fill(' ');
                }
            },
            
            updateInfo() {
                 this.infoContainer.innerHTML = `<div id="galaga-info">Time: ${this.timeLeft}s | Score: ${this.score} / ${this.targetScore}</div>`;
            },

            start() {

                this.tiltGamma = 0;
                if (isMobile && window.DeviceOrientationEvent){
                    const orientCb = e => { this.tiltGamma = e.gamma || 0; };
                    if (DeviceOrientationEvent.requestPermission){
                        DeviceOrientationEvent.requestPermission().then(p=>{
                            if (p==='granted') window.addEventListener('deviceorientation',orientCb);
                        });
                    }else{
                        window.addEventListener('deviceorientation', orientCb);
                    }
                    /* tap anywhere on frame to shoot */
                    this.touchShootHandler = e => {
                        e.preventDefault();
                        e.stopPropagation();   
                        this.spawnBullet();
                    };
                    this.container.addEventListener('touchstart', this.touchShootHandler, tapBlock);
                }


                this.isActive = true;
                this.callbacks.addToLog("Astro Garden started. Left/Right Arrows to move, Space to shoot.");
                document.addEventListener('keydown', this.handleKeyDown);
                document.addEventListener('keyup',   this.handleKeyUp);
                
                this.spawnTimers.mainLoop = setInterval(() => {
                    if (!this.isActive || this.timeLeft <=0) return;
                    this.timeLeft--;
                    this.updateInfo();
                    if (this.timeLeft <= 0) this.checkGameEnd();
                }, 1000);

                this.spawnTimers.enemy = setInterval(() => { if (this.isActive) this.spawnEnemy(); }, this.currentEnemySpawnInterval);
                this.spawnTimers.asteroid = setInterval(() => { if (this.isActive) this.spawnAsteroid(); }, this.currentAsteroidSpawnInterval);

                this.gameLoopId = requestAnimationFrame(this.gameLoop);
            },

            end() {
                this.isActive = false; 
                if (this.gameLoopId) cancelAnimationFrame(this.gameLoopId);
                this.gameLoopId = null;
                
                Object.values(this.spawnTimers).forEach(timerId => clearInterval(timerId));
                this.spawnTimers = {};

                document.removeEventListener('keydown', this.handleKeyDown);
                document.removeEventListener('keyup',   this.handleKeyUp);
                
                if (this.touchShootHandler) {
                    this.container.removeEventListener('touchstart', this.touchShootHandler, tapBlock);
                    this.touchShootHandler = null;
                }

                this.callbacks.addToLog("Astro Garden ended.");

            },
            
            gameLoop: () => { 
                if (!GalagaGame.isActive) return; 
                GalagaGame.updateGameObjects();
                GalagaGame.checkCollisions(); // This might call gameOver, which sets isActive=false
                if (!GalagaGame.isActive) return; // Re-check after collisions
                GalagaGame.renderGameScreen();
                GalagaGame.gameLoopId = requestAnimationFrame(GalagaGame.gameLoop);
            },

            handleKeyDown(e) {
                if (!GalagaGame.isActive) return;
                if (e.key === 'ArrowLeft')  GalagaGame.keysPressed.left  = true;
                if (e.key === 'ArrowRight') GalagaGame.keysPressed.right = true;
                if (e.key === ' ') { e.preventDefault(); GalagaGame.spawnBullet(); }
            },

            handleKeyUp(e) {
                if (e.key === 'ArrowLeft')  GalagaGame.keysPressed.left  = false;
                if (e.key === 'ArrowRight') GalagaGame.keysPressed.right = false;
            },

            spawnEnemy() {
                const x = Math.floor(Math.random() * (this.config.screenWidthChars - 2)); 
                this.enemies.push({ x, y: 0, char: ' V ', colour:'#04A5FF', width: 3, type:'plant', points:50, speed:this.currentEnemySpeed });
            },
            spawnAsteroid() {
                 const x = Math.floor(Math.random() * this.config.screenWidthChars);
                 this.asteroids.push({ x, y: 0, char: '*', colour:'#FF3030', width:1,type:'asteroid', speed:this.currentEnemySpeed*0.8 });
            },
            spawnBullet() {
                if (this.bullets.length < 5) { 
                    this.bullets.push({x: this.player.drawX + Math.floor(this.player.width / 2), y: this.player.y - 1, prevY: this.player.y - 1, char: '|'});
                }
            },

            updateGameObjects() {

                let vx = 0;

                // tilt first
                if (isMobile){
                    if (this.tiltGamma < -5)      vx = -this.playerSpeed+0.05;
                    else if (this.tiltGamma > 5)  vx =  this.playerSpeed-0.05;
                }

                // keyboard (if pressed) overrides tilt
                if (this.keysPressed.left)       vx = -this.playerSpeed;
                else if (this.keysPressed.right) vx =  this.playerSpeed;

                this.player.vx = vx;

                this.player.x += this.player.vx;
                this.player.x = Math.max(0,
                    Math.min(this.config.screenWidthChars - this.player.width,
                        this.player.x));

                this.player.drawX = Math.round(this.player.x);
                
                this.bullets.forEach(b => {b.prevY = b.y;b.y -= 1;});
                this.bullets = this.bullets.filter(b => b.y >= -2);

                this.enemies.forEach(e => e.y += e.speed);
                this.enemies = this.enemies.filter(e => e.y < this.config.screenHeightChars +1); 
                
                this.asteroids.forEach(a => a.y += a.speed);
                this.asteroids = this.asteroids.filter(a => a.y < this.config.screenHeightChars + 1);
            },

            checkCollisions() {
                if(!this.isActive) return;

                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];

                        const crossesRow = bullet.prevY >= enemy.y && bullet.y <= enemy.y + 0.99;  

                        if (crossesRow && bullet.x >= enemy.x && bullet.x <  enemy.x + enemy.width) {
                            this.score += enemy.points;
                            this.callbacks.updateTotalScore(enemy.points); 
                            this.enemies.splice(j, 1);
                            this.bullets.splice(i, 1);
                            this.updateInfo();
                            break; 
                        }
                    }
                }

                const playerY = Math.floor(this.player.y);
                [...this.enemies, ...this.asteroids].forEach(obj => {
                    if(!this.isActive) return; // Check again in case a collision already ended the game
                    const objY = Math.floor(obj.y);
                    if (objY < playerY + 1 && objY +1 > playerY && 
                        this.player.drawX < obj.x + obj.width &&
                        this.player.drawX + this.player.width > obj.x) {
                        this.gameOver("Collision!");
                    }
                });
            },
            
            renderGameScreen() {
                if(!this.gameScreen) return; // Screen element might not be ready on very first call or after end
                for (let r = 0; r < this.config.screenHeightChars; r++) {
                    for (let c = 0; c < this.config.screenWidthChars; c++) {
                        this.charBuffer[r][c] = '&nbsp;';
                    }
                }

                for (let i = 0; i < this.player.width; i++) {
                    if (this.player.drawX + i < this.config.screenWidthChars && this.player.drawX + i >= 0) {
                         this.charBuffer[this.player.y][this.player.drawX + i] = this.player.char[i];
                    }
                }
                this.bullets.forEach(b => {
                    const y = Math.floor(b.y);
                    const x = Math.floor(b.x);
                    if (y >= 0 && y < this.config.screenHeightChars && x >=0 && x < this.config.screenWidthChars) this.charBuffer[y][x] = b.char;
                });
                this.enemies.forEach(e => {
                     const y = Math.floor(e.y);
                     if (y >=0 && y < this.config.screenHeightChars) {
                        for (let i = 0; i < e.width; i++) {
                           const x = Math.floor(e.x + i);
                           if (x < this.config.screenWidthChars && x >= 0) this.charBuffer[y][x] = `<span style="color:${e.colour}">${e.char[i]}</span>`;
                        }
                     }
                });
                this.asteroids.forEach(a => {
                    const y = Math.floor(a.y);
                    const x = Math.floor(a.x);
                     if (y >=0 && y < this.config.screenHeightChars && x >=0 && x < this.config.screenWidthChars) this.charBuffer[y][x] = `<span style="color:${a.colour}">${a.char}</span>`;
                });
                this.gameScreen.innerHTML = this.charBuffer.map(row => row.join('')).join('\n');
            },
            
            checkGameEnd() { 
                if (!this.isActive) return; 
                if (this.score >= this.targetScore) {
                    this.gameWon();
                } else {
                    this.gameOver(`Time up! Score ${this.score} < Target ${this.targetScore}`);
                }
            },

            gameWon() {
                 if (!this.isActive) return;
                 this.isActive = false; 
                 this.callbacks.addToLog("Astro Garden wave survived and target score met!");
                 this.callbacks.onWin(0); 
            },
            gameOver(reason) {
                if (!this.isActive) return;
                this.isActive = false; 
                this.callbacks.addToLog(`Astro Garden failed: ${reason}`);
                this.callbacks.onLoss(reason);
            }
        };

        /* ──────────────────────────────────────────────────────────────
        Root Circuit  v2.0 — Enhanced Unsolved Start & Pathing Robustness
        ---------------------------------------------------------------- */
        const RootCircuitGame = {
            name : "Root Circuit",

            /* injected by ArcadeManager */
            container:null, infoContainer:null, cycle:1, callbacks:null,

            /* runtime */
            grid:[], gridSize:0, timeLeft:0, timerId:null, solved:false,
            startCol:0, endCol:0,

            /* constants */
            config : {sizes:[6,7,9,11,13], times:[60,70,80,90,100]},
            DIRS   : [[-1,0],[0,1],[1,0],[0,-1]],                  // U,R,D,L (Indices: 0,1,2,3)
            SHAPES : [                                              // base rotations (U,R,D,L openings)
                [1,0,1,0], /* I vertical   (U,D) */
                [0,1,0,1], /* I horizontal (R,L) */
                [1,1,0,0], /* L North-East (U,R) */
                [0,1,1,0], /* L East-South (R,D) */
                [0,0,1,1], /* L South-West (D,L) */
                [1,0,0,1]  /* L West-North (L,U) */
            ],

            /* ───────────────── life-cycle ───────────────── */
            init(container,infoContainer,cycle,cb){
                Object.assign(this,{container,infoContainer,cycle,callbacks:cb});
                const idx=Math.min(cycle-1,this.config.sizes.length-1);
                this.gridSize=this.config.sizes[idx];
                this.timeLeft=this.config.times[idx];
                this.solved=false;
                this.buildGrid();
                this.render();
                this.updateInfo();
            },
            start(){
                this.callbacks.addToLog(
                "Root Circuit: rotate tiles to link S (green) to E (red)."
                );
                this.timerId=setInterval(()=>{
                if (this.solved) return;
                this.timeLeft--; this.updateInfo();
                if(this.timeLeft<=0) this.gameOver("Signal surge – circuit overloaded!");
                },1000);
            },
            end(){
                clearInterval(this.timerId);
                this.timerId = null;
                this.callbacks?.addToLog("Root Circuit ended.");
            },

            /* ───────────────── UI ───────────────── */
            updateInfo(){
                this.infoContainer.innerHTML=
                `<div id="rootcircuit-info">⏱ ${this.timeLeft}s   Grid ${this.gridSize}×${this.gridSize}</div>`;
            },
            render(){
                this.container.innerHTML='<div id="rootcircuit-grid" class="grid-display"></div>';
                const g=document.getElementById('rootcircuit-grid');
                g.style.gridTemplateColumns=`repeat(${this.gridSize},24px)`;
                g.style.gridTemplateRows   =`repeat(${this.gridSize},24px)`;

                for(let r=0;r<this.gridSize;r++){
                for(let c=0;c<this.gridSize;c++){
                    const t=this.grid[r][c], cell=document.createElement('div');
                    cell.className='grid-cell';
                    if(r===0 && c===this.startCol)         cell.classList.add('rc-start');
                    if(r===this.gridSize-1 && c===this.endCol) cell.classList.add('rc-end');
                    
                    cell.innerHTML=this.svg(t.shapeIdx,t.rot);

                    if(!((r===0 && c===this.startCol) || (r===this.gridSize-1 && c===this.endCol))){
                        cell.onclick=()=>{
                            if(this.solved || this.timeLeft <= 0) return;
                            t.rot=(t.rot+1)&3;
                            cell.innerHTML=this.svg(t.shapeIdx,t.rot);
                            this.trySolve();
                        };
                    }
                    g.appendChild(cell);
                }
                }
            },
            svg(s,rot){
                const p=[
                `<rect x="10" y="3"  width="4" height="18" rx="2"/>`,
                `<rect x="3"  y="10" width="18" height="4" rx="2"/>`,
                `<rect x="10" y="3"  width="4" height="10" rx="2"/> <rect x="10" y="10" width="7" height="4" rx="2"/>`,
                `<rect x="10" y="10" width="7" height="4" rx="2"/> <rect x="10" y="10" width="4" height="10" rx="2"/>`,
                `<rect x="10" y="10" width="4" height="10" rx="2"/> <rect x="3"  y="10" width="7" height="4" rx="2"/>`,
                `<rect x="3"  y="10" width="7" height="4" rx="2"/> <rect x="10" y="3"  width="4" height="10" rx="2"/>`
                ];
                return `<svg width="24" height="24" viewBox="0 0 24 24">
                        <defs><filter id="g"><feGaussianBlur stdDeviation="1.4" result="c"/>
                        <feMerge><feMergeNode in="c"/><feMergeNode in="SourceGraphic"/>
                        </feMerge></filter>
                        <style><![CDATA[rect{fill:#00ff80;filter:url(#g);}]]></style></defs>
                        <g transform="rotate(${rot*90} 12 12)">${p[s]}</g></svg>`;
            },

            /* ───────────── grid generation  (start-solved mode) ───────────── */
            buildGrid () {
                /* 1. choose size + start / end columns */
                this.startCol = Math.floor(Math.random() * this.gridSize);
                do { this.endCol = Math.floor(Math.random() * this.gridSize); }
                while (this.endCol === this.startCol && this.gridSize > 1);

                /* 2. allocate empty cells */
                this.grid = Array.from({ length: this.gridSize }, () =>
                    Array.from({ length: this.gridSize }, () => ({}))
                );

                /* 3. lay a SOLVED path S → E (existing helpers) */
                const path = this.makePath();                    // guaranteed list of [r,c]
                if (!path || path.length < 2) return console.error("makePath failed");

                const put = (r, c, shapeIdx, rot) => {
                    this.grid[r][c] = { shapeIdx, rotSolved: rot, rot };      // rot == solved
                };

                for (let i = 0; i < path.length; i++) {
                    const [r, c] = path[i];

                    if (i === 0 || i === path.length - 1) {           // start / end → vertical “I”
                        put(r, c, 0, 0);
                        continue;
                    }
                    const [pr, pc] = path[i - 1];
                    const [nr, nc] = path[i + 1];
                    const inDir  = this.dirIdx(pr, pc, r, c);
                    const outDir = this.dirIdx(r, c, nr, nc);
                    const { shapeIdx, rot } = this.tileFor(inDir, outDir);
                    put(r, c, shapeIdx, rot);
                }

                /* 4. fill every NON-path cell with any random tile (rotation irrelevant) */
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize; c++) {
                        if (this.grid[r][c].rotSolved === undefined) {
                            this.grid[r][c] = {
                                shapeIdx : Math.floor(Math.random() * this.SHAPES.length),
                                rotSolved: 0,
                                rot      : 0       // keep neutral so it can’t break the path
                            };
                        }
                    }
                }

                this.solved = this.isSolved();
                /* 5. done – no scramble; board is immediately solvable */
            },
            
            /* build path: wander until row-1, move horiz. to endCol, then step down */
            makePath(){ // User's original makePath function
                const p=[[0,this.startCol]];
                let r=0,c=this.startCol;

                /* ➜ guarantee we leave Start by moving down once */
                if (this.gridSize > 1) {
                    r = 1;
                    p.push([r, c]);         // first step directly under the S tile
                }
                
                // Ensure r and c stay within bounds during path generation for stability
                const max_r = this.gridSize - 1;
                const max_c = this.gridSize - 1;

                // Target row for horizontal alignment before final drop
                const alignment_r = Math.max(0, this.gridSize - 2); 

                while(r < alignment_r && p.length < this.gridSize * this.gridSize){ // Loop guard
                    const moves=[[1,0],[1,0]]; // bias down
                    if(c > 0) moves.push([0,-1]);
                    if(c < max_c) moves.push([0,1]);
                    
                    const [dr,dc]=moves[Math.floor(Math.random()*moves.length)];
                    
                    let next_r = r + dr;
                    let next_c = c + dc;

                    // Clamp to bounds (though moves should mostly prevent this if logic is tight)
                    next_r = Math.max(0, Math.min(max_r, next_r));
                    next_c = Math.max(0, Math.min(max_c, next_c));

                    // Avoid getting stuck if next move is same cell and path is short
                    if (next_r === r && next_c === c && p.length < 3) {
                        // If stuck early, try a different move if possible, or just break to next phase.
                        // This might happen if gridSize is very small.
                        // For now, allow it, rely on loop guard.
                    }
                    
                    r = next_r;
                    c = next_c;

                    // Add if not forming an immediate 2-step loop back to previous (p[len-2])
                    if (p.length < 2 || (r !== p[p.length-2][0] || c !== p[p.length-2][1])) {
                        p.push([r,c]);
                    } else {
                        // Backtracked into previous-previous, try to unstick or accept shorter path part
                        // For simplicity, we might just remove the last step that formed the loop
                        // p.pop(); // remove p[len-1]
                        // r = p[p.length-1][0]; c = p[p.length-1][1];
                        // and try a different move (more complex logic) or let loop continue.
                    }
                }
                // Ensure r is at alignment_r for horizontal movement phase
                while (r < alignment_r && p.length < this.gridSize * this.gridSize) {
                    r++; p.push([r,c]);
                }
                while (r > alignment_r && p.length < this.gridSize * this.gridSize) { // if overshot
                    r--; p.push([r,c]);
                }


                while(c !== this.endCol && p.length < this.gridSize * this.gridSize){
                    c+=(c < this.endCol) ? 1 : -1;
                    // Clamp c if it somehow goes out of bounds
                    c = Math.max(0, Math.min(max_c, c));
                    p.push([r,c]);
                }
                
                // Final drop to end row (gridSize - 1)
                while(r < max_r && p.length < this.gridSize * this.gridSize){
                    r++;
                    p.push([r,c]);
                }

                // Sanitize: Remove consecutive duplicate points from path
                const finalPath = [];
                if (p.length > 0) {
                    finalPath.push(p[0]);
                    for(let i = 1; i < p.length; i++) {
                        if (p[i][0] !== finalPath[finalPath.length-1][0] || p[i][1] !== finalPath[finalPath.length-1][1]) {
                            finalPath.push(p[i]);
                        }
                    }
                }
                // Ensure the very last point is indeed the target end cell if path generation was odd
                if (finalPath.length > 0) {
                    const lastPt = finalPath[finalPath.length-1];
                    if (lastPt[0] !== max_r || lastPt[1] !== this.endCol) {
                        // If path didn't end at target, try to force it or log error
                        // For now, remove last and add correct end
                        if (lastPt[0] !== this.gridSize -1 || lastPt[1] !== this.endCol) {
                            finalPath.push([this.gridSize - 1, this.endCol]);
                            // Re-sanitize after adding
                            const reSanitized = [];
                            if (finalPath.length > 0) {
                                reSanitized.push(finalPath[0]);
                                for(let i = 1; i < finalPath.length; i++) {
                                    if (finalPath[i][0] !== reSanitized[reSanitized.length-1][0] || finalPath[i][1] !== reSanitized[reSanitized.length-1][1]) {
                                        reSanitized.push(finalPath[i]);
                                    }
                                }
                                return reSanitized;
                            }
                        }
                    }
                }
                return finalPath;
            },
            tileFor(inDir,outDir){
                for(let s=0;s<this.SHAPES.length;s++){
                    for(let rot=0;rot<4;rot++){
                        const d=this.rot(this.SHAPES[s],rot);
                        if(d[inDir]&&d[outDir]&&d.filter(Boolean).length===2){
                            return {shapeIdx:s,rot};
                        }
                    }
                }
                // Fallback if no specific L or I shape matches (should be rare with complete SHAPES)
                // This might happen if inDir and outDir are the same, indicating a 0-length segment.
                // Default to a vertical I, hoping it's less disruptive.
                return {shapeIdx:0,rot:0};
            },

            /* helpers */
            shuffle(arr){for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];}return arr;},
            rot(bools,rotation){
                const out=[false,false,false,false];
                for(let d=0;d<4;d++) out[(d+rotation)&3] = bools[d];
                return out;
            },
            dirIdx(r1,c1,r2,c2){
                if(r2<r1) return 0; // Up
                if(c2>c1) return 1; // Right
                if(r2>r1) return 2; // Down
                if(c2<c1) return 3; // Left
                return -1; // Error: same cell
            },

            /* ───────────── solving logic ───────────── */
            dirs(tile){
                if (!tile || tile.shapeIdx === undefined) return [0,0,0,0]; // Handle undefined tile robustly
                return this.rot(this.SHAPES[tile.shapeIdx],tile.rot);
            },
            canEnter(r,c,fromDir){
                if(r<0||r>=this.gridSize||c<0||c>=this.gridSize) return false;
                const tile = this.grid[r]?.[c];
                if (!tile || tile.shapeIdx === undefined) return false; // Cell or tile not defined
                return this.dirs(tile)[(fromDir+2)&3]; 
            },
            dfs(r,c,visited){
                if(r===this.gridSize-1 && c===this.endCol) return true;
                visited[r][c]=true;

                const currentTile = this.grid[r]?.[c];
                if (!currentTile || currentTile.shapeIdx === undefined) return false; // Should not happen if pathing correctly

                const currentTileDirs=this.dirs(currentTile);
                for(let exitDir=0; exitDir<4; exitDir++){
                    if(currentTileDirs[exitDir]){
                        const nr = r + this.DIRS[exitDir][0];
                        const nc = c + this.DIRS[exitDir][1];
                        if (nr < 0 || nr >= this.gridSize || nc < 0 || nc >= this.gridSize || visited[nr]?.[nc]) continue;

                        if(this.canEnter(nr,nc,exitDir)){ // Check if neighbor can be entered from this direction
                            if(this.dfs(nr,nc,visited)) return true;
                        }
                    }
                }
                return false;
            },
            isSolved(){
                const startTile = this.grid[0]?.[this.startCol];
                if (!startTile || !this.dirs(startTile)[2]) return false; // Must be able to exit Down from Start

                const visited=Array.from({length:this.gridSize},()=>Array(this.gridSize).fill(false));
                return this.dfs(0,this.startCol,visited);
            },
            trySolve(){
                if(this.solved) return;
                if(this.isSolved()){
                    this.solved=true;
                    clearInterval(this.timerId);
                    this.timerId = null;
                    const score=250 + (this.timeLeft * 5);
                    this.callbacks.addToLog(`Root Circuit complete! +${score}`);
                    this.updateInfo();
                    this.callbacks.onWin(score);
                }
            },

            /* ───────────── fail ───────────── */
            gameOver(reason){
                if(this.solved || !this.timerId) return;
                clearInterval(this.timerId);
                this.timerId = null;
                this.callbacks.addToLog(`Root Circuit failed: ${reason}`);
                this.callbacks.onLoss(reason);
            }
        };



        // --- Initialize Arcade ---
        window.onload = () => {
            ArcadeManager.init();
        };
    </script>
</body>
</html>